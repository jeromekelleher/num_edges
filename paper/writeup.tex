\documentclass[10pt,twoside,lineno]{gsajnl}
\articletype{inv} % article type

\usepackage[dvipsnames]{xcolor}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{natbib}
\usepackage[linesnumbered,ruled,vlined,algo2e]{algorithm2e}
\usepackage{tikz}
\usetikzlibrary{arrows, snakes,backgrounds}
\tikzstyle{place}=[circle,draw=black,thick, inner sep=0pt, minimum size = 5mm]
\usepackage{hyperref}
\hypersetup{
	pagebackref=true,
	colorlinks = true,
	allcolors = OliveGreen}

\SetKwInput{input}{Input}
\SetKwInput{output}{Output}


\newcommand{\E}{\mathbb{E}}
\renewcommand{\P}{\mathbb{P}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\T}{\mathbb{T}}
\newcommand{\tn}{\textnormal}
\newcommand{\ov}{\overline}
\newcommand{\tskit}{\texttt{tskit}}
\newcommand{\comment}[1]{{\color{violet} \it #1}}
\newcommand{\argmax}{\operatorname{argmax}}

\newcommand{\algorithmref}[2][]{%
	\hyperref[{#2}]{%
		Algorithm~\ref*{#2}%
		\ifx\\#1\\%
		\else
		\,#1%
		\fi
	}%
}

\newcommand*{\figref}[2][]{%
	\hyperref[{#2}]{%
		Figure~\ref*{#2}%
		\ifx\\#1\\%
		\else
		\,#1%
		\fi
	}%
}




\title{
    A forest is more than its trees:
    haplotypes and inferred ARGs
}

% Information in recombination junctions can both compress and improve inferred tree sequences
% Non-coalescing regions of dark matter in ARGs
% Can we find them? Are they useful in inference, dating? 
% Look, we can find them and they seem at least useful for compression.
% Also, here's a way of measuring agreement that takes this sort of thing into account,
%  which extends R-F to measure haplotypes


% NOTE: these are in alphabetical order for now; we can revisit that ordering
\author[$\dagger$]{Ava Bamforth}
\author[$\dagger$]{Halley Fritze}
\author[$\ddagger$]{Jerome Kelleher}
\author[$\dagger$]{Nathaniel Pope}
\author[$\ast$,$\dagger$,1]{Peter Ralph}

\affil[$\ast$]{Institute of Evolution and Ecology and Department of Biology, University of Oregon, Eugene, Oregon}
\affil[$\dagger$]{Department of Mathematics, University of Oregon, Eugene, Oregon}
\affil[$\ddagger$]{Big Data Institute, Li Ka Shing Centre for Health Information and Discovery, University of Oxford}


\keywords{genealogy, tree sequence, haplotypes}

\runningtitle{Junctions in tree sequences}
\runningauthor{Bamforth \textit{et al.}}

%%%%%%%%%%
\begin{abstract}
    Foreshadowing haplotype-based methods of the genomics era,
    it is an old observation that the ``junction'' between two distinct haplotypes
    produced by recombination is inherited as a Mendelian marker.
    In this paper, we describe how this recombination-mediated information
    can in many cases be recovered from inference based solely on
    polymorphic markers (i.e., information produced by mutation),
    which produces unary nodes along the branches of the marginal genealogical trees.
    The resulting inferred ARGs, represented as tree sequences,
    are smaller, faster to compute with,
    and potentially contain substantially more information
    about the age of ancestral haplotypes,
    than inferred ARGs without these unary nodes.
    We provide efficient algorithms to identify this ancestral haplotype information,
    new metrics of agreement/disagreement between inferred ARGs,
    and explore some consequences for ARGs inferred from real data.
\end{abstract}

\begin{document}

\maketitle
\thispagestyle{firststyle}
\marginmark
\firstpagefootnote

\correspondingauthoraffiliation{1}{Corresponding author: {plr@uoregon.edu}}
\vspace{-33pt}% Only used for adjusting extra space in the left column of the first page

\comment{idea: look at ratio of unary-to-not over time; does it change with
    selection? or modes of recombination?}

%%% OUTLINE
% Intro: haplotypes, unary bits of non-coalescing nodes, ARGS, etcetera
%    explain what tsinfer does to create unary regions
%    statement of problem
%    Yan: are breakpoints in true->simplify->extend the same as in original?
%   Fig 1: conceptual figure
%    Also IBD gets screwed up
% 
% Methods:
%   edge extend algorithm
%   discrepancy funciton algorithm
%   Fig 2: Conceptual figure for discrepancy
% 
% Results:
%   Fig 3:
%     (a) reduction in number of edges and (b) speed change
%
%   Fig 4:
%     Histograms of (a) total span added, (b) percent incorrect
%
%   Fig 5 and maybe 6: how it interacts with tsinfer
%     (a) summarize total matching and unmatching span (or maybe percent matching?)
%           across reps
%     (b) discrepancy per node against depth or time or number of subtended samples
%        describe percent span matched against true span or depth or something
%
%   Fig 7(?): compare IBD stats before/after
% 
% Supp:
%   S1: runtime
%%%


% Name ideas:
% 
% extend edges
% bundle edges
% inflate edges
% bundle lines of descent
% longer ancestral haplotypes
% inflated ancestors
% compress paths
% optimizing edge tables
% reduce number of ancestors
% reduce ancestral paths


%%%% COLOR SCHEME FOR FIGURES %%%%
% colors = {'blue': 'rgb(46,37,133)',
%	'red': 'rgb(194,106,119)',
%	'lgreen': 'rgb(93,168,153)',
%	'gold': 'rgb(220,205,125)',
%	'green': 'rgb(51, 117,56)',
%	'lblue': 'rgb(148,203,236)',
%	'magenta': 'rgb(159,74,150)',
%	'wine': 'rgb(126,041,084)', 
%}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

% PETER
% * what's a tree sequence
% * why is a tree sequence (motivation)

There has been substantial recent progress
in the problem of ``ARG inference'',
which seeks to infer (portions of) the ``ancestral recombination graph'' (or, ARG)
that describes how a set of genotypes samples are related to each other
at each position of the genome.
For reviews of this progress, see CITE CITE CITE.
Often such methods focus on the sequence of ``marginal trees'',
i.e., the genealogical trees that describe how each portion of the genome
was inherited by the focal genomes.
For instance, the ``succinct tree sequence'',
introduced by \citet{kelleher2016efficient},
is a common format for describing these inferred ARGs,
and is seeing wide use thanks in part to its efficiency and accompanying reliable toolkit,
\tskit (CITE).

However, the ARG is emphatically not merely a sequence of trees:
since each segment of an ancestor's genome that has been inherited by the focal genomes
may extend over a portion of the genome over which there are many distinct trees,
a single ancestor should usually be represented by nodes in many distinct trees.
In other words, one way to view an ARG is as a sequence of trees in which nodes may be shared across many trees,
but another way to view the ARG is as a set of relationships between segments of ancestral haplotypes.

Another reason we tend to focus on the trees is that
much of our intuition about inference of relationships from genomic data
comes from phylogenetics.
Indeed, all methods might very roughly be summarized as
``more similar sequences are more closely related''.
For instance, two sequences that share a drerived mutation
are (probably) more closely related over some span of genome surrounding the location where the mutation occurs.
\citet{fisher} pointed out that not only mutations
but also the ``junctions'' between distinct haplotypes,
if they could be somehow identified,
would be inherited as Mendelian markers.

\subsection{Motivation and statement of problem}

% PETER
% * minimize number of edges
% * gives extra info about shared haplotypes, reduces number of ancestral paths

Consider the (small portion) of a hypothetical tree sequence in Figure~\ref{fig:conceptual}A.
On the first portion of the genome (left-hand tree), the sample nodes (labeled 0, 1, and 2)
coalesce into a small subtree: 1 and 2 find a common ancestor in ancestral node 3,
which finds a common ancestor with node 0 in ancestral node 4.
On the next portion of the genome (right-hand tree), sample node 2 has a different ancestor.
This seems reasonable, and a method that infers trees separately on each portion of the genome
could not be expected to produce anything different.
However, things change once we think about what this implies about haplotype inheritance.
Figure~\ref{fig:conceptual}B shows the implied inheritance of haplotypes,
with the haplotypes carried by 4 to the left and right of the recombination breakpoint labeled $L$ and $R$.
Here, sample node 2 has inherited the chunk of haplotype labeled $L$ from ancestral node 4 via 3,
and the haplotype to the right of this from some other node (and so doesn't carry haplotype $R$).
On the other hand, sample node 1 has inherited \emph{both} haplotypes $L$ and $R$
from ancestral node 4, but the trees imply that only haplotype $L$ is inherited via ancestral node 3.
This implies -- if taken literally -- that there must have been a recombination event
at some point between node 1 and node 4 that separated the $L$ and $R$ haplotypes,
and then these two ancestral (and nonoverlapping) haplotypes coalesced together in ancestral node 4.
Although this is possible, it seems unlikely --
a more parsimonious explanation is depicted in Figure~\ref{fig:conceptual}C,
in which sample node 1 inherits the entire $LR$ haplotype from ancestral node 4 through node 3
(and there is a recombination somewhere between node 3 and node 2).
This implies that ancestral node 3 inherits from node 4 on the right-hand tree as well,
which is depicted in Figure~\ref{fig:conceptual}D --
and so node 3 has become unary in this tree.
Note that the more parsimonious tree sequence also includes fewer edges:
the three distinct edges $4 \to 3$, $3 \to 1$, and $4 \to 1$ in Figure~\ref{fig:conceptual}B
have been reduced to the two edges
$4 \to 3$ and $3 \to 1$ in Figure~\ref{fig:conceptual}D.

\begin{figure}
    \begin{center}
    \includegraphics[width=0.9\textwidth]{conceptual_figure.pdf}
    \end{center}
    \caption{
        A simple example showing the basic idea
        (described in more detail in the text):
        \textbf{(A)} a small portion of a tree sequence without unary nodes;
        \textbf{(B)} the implied inheritance pattern of the two portions of the haplotype carried by ancestral node 4,
        labeled $L$ and $R$;
        \textbf{(C)} marginal trees with a unary node added,
        which produces \textbf{(D)} a more parsimonious haplotype inheritance pattern
        (that also includes fewer edges).
        \label{fig:conceptual}
    }
\end{figure}

\section{Methods}

%\subsection{Extend Edges}
%	\comment{Should we keep a brief section about the original extend edges? If yes, some notes are below.}
%    We do so by identifying short paths (2 edges) in a tree.
%    If neighboring trees contain edges with 
%    identical ancestor (parent) and descendant (child) nodes, 
%    we assume that there is implied coalescence of haplotypes between nodes, 
%    and we will extend the path's edges to the neighboring tree \ref{fig:extending_diagram}.
%  	In more concrete terms, for a tree $T_k$ in the tree sequence $\T$ 
%    suppose there exists a path which contains a node $3$,
%    with parent and child nodes $4$ and $0$, respectively.
%    If there is an edge between the nodes $4$ and $0$ in trees 
%    $T_{k+1}$ (or $T_{k-1}$),
%    then we wish to extend the edges $4\to 3$ and $3\to 0$ 
%    into tree $T_{k+1}$ and then remove the edge $4 \to 0$ from $T_{k+1}$. 
%    This action reduces the length of $4 \to 0$ on the genome,
%    and in some cases, completely removes the edge. 
%    We now perform this action on all such ancestral paths 
%    over the entire tree sequence.
%    With algorithm \ref{alg:edge} we only extend existing edges
%    \comment{Note possible change pending algorithm change}
%    over a larger interval on the genome,
%    and remove unnecessary edges in the process.

\subsection{Extend Haplotypes}

% * description (HALLEY)
% * proof of something:
%     - arrives at a local minimum?
%     - guess at typical reduction? (reduces edges by 1/3?)
    We define a \textit{tree sequence}, denoted $\T$, 
    as a tuple $\left(T_1,...,T_{|\T|}\right)$ of $|\T|$ trees with a sequence of points
	$0 = a_0 \leq a_1 \leq \cdots < a_{|\T|} = L$.
     Each $T_k$ is a tree describing genealogical relationships between samples
     over a distinct portion of the genome $[a_{k-1}, a_k)$.
    Given any tree sequence, our goal is to
    identify areas of implied inheritance of haplotypes.
    We do so by identifying paths in pairs of consecutive tree sequences
    and merging them, given the correct condition.
    For example, \figref{fig:extending_diagram}, if there exists paths neighboring trees which contain 
    identical ancestor (parent) and descendant (child) nodes, 
    we assume that there is implied coalescence of haplotypes between nodes, 
    and we will extend the path's edges to the neighboring tree.
     More generally, see \algorithmref{alg:hap}, for a pair of trees $T_k, T_{k+1}\in\mathbb{T}$,
     to transition from tree $T_k$ to tree $T_{k+1}$ we identify the 
     subforest of edges in $T_k$ that are removed to construct $T_{k+1}$
     and the subforest of edges in $T_{k+1}$ which were added to construct 
     $T_{k+1}$ from $T_k$. We call these subforests the out-forest and in-forest, respectively,
     and denote them as $F_O$ and $F_O$.
     For each edge $e \in F_O$ with child $c$,
     we construct a path $p_c^{F_O}$ comprised of edges in the $F_O$ subforest.
     If there exists an edge $e'\in F_I$ also with child $c$,
     we construct path $p_c^{F_I}$ from edges in the $F_I$ subforest.
     If there is a common node in both paths excluding $c$, ie. $(p_c^{F_O}\cap p_c^{F_I})\backslash \{c\}\neq\emptyset$, then there is a mergable path between both subforests. The merged path $\bar{p}_c = \hat{p}_c^{F_I} \cup \hat{p}^{F_O}$ is the union of both paths truncated ($\hat{p}$) at the common intersection node. We then insert $\bar{p}$ into $T_2$, postponing or deleting edges in its original in-forest $F_I$, see \figref{complicated_extending_diagram}. We perform this action across all consecutive pairs of tree sequences, going both forward and backward along the genome, until there are no more edges extended in this way.


\begin{figure}[!ht]
\begin{center}
	\includegraphics[width=5in]{edge_extend_method.pdf}
\end{center}
\caption{\comment{Change figure to say Extend halplotypes}A visualization of the \textit{extend haplotypes} method. Given two neighboring trees $T_1$ and $T_2$, $F_O$ in the tree $T_1$ contains the edge $3\to 0$. Starting at $0$, there is a path of edges $0 \to 3 \to 4$. The tree $T_2$ has edge $4 \to 0$ in $F_I$, and so there exists path $0 to 4$. These two paths share common end points, $0$ and $4$, and so we will extend path $0 \to 3 \to 4$ onto tree $T_2$, hence removing the edge $4\to 0$.
    \label{fig:extending_diagram}
}
\end{figure}

\begin{figure}[!ht]
	\begin{center}
		\includegraphics[width=0.4\linewidth, height=1.2in]{EH-Ex2.pdf}
		\includegraphics[width=0.4\linewidth, height=1.2in]{EH-extended-Ex2.pdf}
	\end{center}
	\caption{\comment{Change figure to have the same arrow with 'Extend Haplotypes' in inkscape for unity's sake.}The extend haplotypes method between tree with more unary nodes. Given two neighboring trees, there exists paths $4\to 6\to8\to10$ and $5\to 9\to 10$ in $F_O$, and in $F_I$ we have paths $4\to 7\to 11\to 10$ and $5\to 12\to 10$. Both the out-forest and in-forest both contain paths with the same initial and terminal nodes, $4\to 10$ and $5\to 10$ respectively, we merge both paths and output the tree sequence on the right.}
	\label{fig:complicated_extending_diagram}
\end{figure}

\begin{algorithm2e}[!ht]
	\SetStartEndCondition{ }{}{}%
	\SetKwProg{Fn}{def}{\string:}{}
	\SetKwFunction{Range}{range}%%
	\SetKw{KwTo}{in}
	\SetKwFor{For}{for}{\string:}{}%
	\SetKwIF{If}{ElseIf}{Else}{if}{:}{elif}{else:}{}%
	\SetKwFor{While}{while}{:}{fintq}%
	\SetKw{Break}{break}
	\newcommand\forcond{$i$ \KwTo\Range{$n$}}
	\AlgoDontDisplayBlockMarkers\SetAlgoNoEnd\SetAlgoNoLine%
	
	\caption{Extends haplotypes across a tree sequence $TS$.}
	\label{alg:hap}
	
	\SetKwFunction{ex}{Extend Paths}
	\SetKwFunction{fp}{Find Paths}
	\DontPrintSemicolon
	\LinesNotNumbered
	%\SetAlgoNoEnd
	\input{A tree sequence $\T$}
	\output{New tree sequence,$\T'$}
	\BlankLine
	\Fn{\fp (tree sequence $\T$, forwards = \tn{True})}{
	{
		\eIf{forwards=\tn{True}}{$\T = \left(T_1,...,T_{|\T|}\right)$\BlankLine}
		{\BlankLine
			$\T = \left(T_{|\T|},..., T_1\right)$\;
		}
	}
		\For{pairs $(T_k, T_{k+1})\in \T\times\T$}{
		Compute subforests $F_O\subseteq T_k$ and $F_I\subseteq\in T_{k+1}$.\;
		\For{edges $e$ in $F_O$}{
			Let $c$ be child node.\;
			$p_c^{F_O} = [c]$\;
			$p_c^{F_I} = [c]$\;
			$\bar{p}_c = []$ Path to be inserted\;
			\While{$\exists f\in F_O$ such that $\tn{child}(f)=c$ and $\tn{deg}(\tn{parent}(f))=0$}{
				$p = \tn{parent}(f)$\;
				Append $p$ to $p_c^{F_O}$\;
				$c = p$\;
			}
			\While{$\exists f\in F_I$ such that $\tn{child}(f)=c$ and $\tn{deg}(\tn{parent}(f))<3$}{
				$p =\tn{parent}(f)$\;
				Append $p$ to $p_c^{F_I}$\;
				$c = p$\;
			}
			\If{($p_c^{F_O}\cap p_c^{F_I})\backslash\{c\}\neq\emptyset$}{
				Merge paths up to intersection point\;
				$\bar{p}_c = \hat{p}_c^{F_I} \cup \hat{p}^{F_I}_c$\;
				and sort by node time.\;
			}
			Insert $\bar{p}_c$ into $T_{k+1}$\;		
		}
	}\;
	Update $\T$.\;
	\KwRet{$\T$}\;
}
\BlankLine						
\Fn{\ex ($\T$)}{
	$\T' \gets $ \fp($\T$, forwards =\tn{True})\;
	$\T' \gets $ \fp($\T$, forwards = \tn{False})\;
	\While{Number of edges in $\T$ $\neq$ Number of edges in $\T'$}{
		$\T' \gets $ \fp($\T$, fowards=\tn{True})\;
		$\T' \gets $ \fp($\T$, fowards=\tn{False})\;
		
	}
	\KwRet{$\T'$}\;
}
\end{algorithm2e}

%% Can most likely delete the extend-edges algorithm %%
%\begin{algorithm2e}[!ht] 
%	
%\SetStartEndCondition{ }{}{}%
%\SetKwProg{Fn}{def}{\string:}{}
%\SetKwFunction{Range}{range}%%
%\SetKw{KwTo}{in}
%\SetKwFor{For}{for}{\string:}{}%
%\SetKwIF{If}{ElseIf}{Else}{if}{:}{elif}{else:}{}%
%\SetKwFor{While}{while}{:}{fintq}%
%\SetKw{Break}{break}
%\newcommand\forcond{$i$ \KwTo\Range{$n$}}
%\AlgoDontDisplayBlockMarkers\SetAlgoNoEnd\SetAlgoNoLine%
%
%\caption{Extends edges across a tree sequence $TS$.}
%\label{alg:edge}
%
%\SetKwFunction{ex}{Extend Edges}
%\SetKwFunction{fwd}{Extend}
%\DontPrintSemicolon
%\LinesNotNumbered
%%\SetAlgoNoEnd
%\input{A tree sequence $\T$}
%\output{New tree sequence,$\T'$}
%
%\BlankLine 
%
%\Fn{\fwd (tree sequence $\T$, forwards = \tn{True})}{
%{	
%\eIf{forwards=\tn{True}}{$\T = \left(T_1,...,T_{|\T|}\right)$\BlankLine}
%{\BlankLine
%	$\T = \left(T_{|\T|},..., T_1\right)$\;}
%}
%	\For{$T_k\in \T$}{
%	Find all edge pairs $(e_1,e_2)$ such that $e_1 = a\to b$ and $e_2 = b\to c$ for some nodes $a,b,c$.\;
%	\For{edges $f$ in $T_{k+1}$}{
%		\If{$f = a \to c$ and $b$ is not in $T_{k+1}$}{
%		Remove $f$ from $T_{k+1}$.\;
%		Add $e_1$ and $e_2$ to $T_{k+1}$.\;
%		Update $\T$.\;
%	}
%	}
%}\;						
%\KwRet{$\T$}\;
%}
%\BlankLine						
%\Fn{\ex ($\T$, iter=100)}{
%	\For{$*$ \KwTo \Range(iter)}{
%		$\T' \gets \T$.\fwd(fowards=\tn{True})\;
%		$\T' \gets \T$.\fwd(fowards=\tn{False})\;
%		\If{Number of edges in $\T$ = Number of edges in $\T'$}{
%			\Break\BlankLine}
%		}
%}
%\KwRet{$\T'$}\;
%\end{algorithm2e}


%% Find counter example to global minimum.

\subsection{Discrepancy Function}
% * How to measure agreement that includes haplotypes
% * Definition and Algorithm
% * Supp fig: runtime ~ # trees, samples
% * fig: how add edges reduces discrepancy (RESULTS)
%       - compare to tsinfer
% * Show: how add edges reduces discrepancy (RESULTS)
% * THINK of a way to asynchronously computing discrepancy (???)

\par \comment{This needs work. Choose $n_1$ or $i$ for node not both. Do you want it through the perspective of TS or through nodes? You wording is mixed on this}
 Now with an algorithm in place
 we need a metric to discern
 if trees modified with extend edges
 in fact correctly infer haplotypes in our original tree sequence.
  % Robinson-Foulds Paper: https://www.sciencedirect.com/science/article/abs/pii/0025556481900432?via%3Dihub 
 An immediate choice of metric would be the Robinson-Foulds metric \comment{CITE} which compares nodes between individual pairs of trees.
 However, in an effort to infer coalescent haplotypes, our function chooses to compare nodes
 across the entire genome. 
 \comment{something something something...}
 
 Inspired by Robinson-Foulds we define a function, called a \textit{discrepancy function} (see \algorithmref{alg:disc}), on a pair of tree sequences $\T_1$, $\T_2$ of equal length $L$.
 Let $N_{T_1}$ and $N_{T_2}$ be the set of nodes on $\T_1$ respectively $\T_2$.
 For a pair of nodes $(i,j)\in N_{T_1}\times N_{T_2}$, we define their \textit{discrepancy} as a difference in their total spans over the genome.
 Each node $n\in\T$ has a given position along the genome and time, 
 so we can write each node as a tuple $n = (t_n, L_n)$ with position $L_n\subset \left[0,L\right)$ and time $t_n\in \R^{\geq 0}$.
 Computing the discrepancy between a random pair of nodes is not helpful, 
 so we must first identify which pairs of nodes would be most identical to one another or a `best match'.
 These `best matching' nodes should be close in terms of time and have equal descendant sample sets,
 ie. $s(i) = s(j)$ where $s$ is the function to compute the descendant sample set of $n_1$.
 
 To find a best match for each node $i\in N_{T_1}$ \comment{(Should I do this by mentioning clades?)}
 we compute the \textit{shared span} between node $i\in N_{T_1}$ and every node in $N_{T_2}$.
 Then, the \textit{shared span} between two tree sequences, denoted $ss(\T_1,\T_2)$, is a $|N_{T_1}|\times |N_{T_2}|$ matrix $A$
 where each entry $a_{ij}$ represents the shared span between a pair of nodes $(i,j)\in N_{T_1}\times N_{T_2}$.
 If a pair $(i,j)$ has equal descendant sample sets, $s(i) = s(j)$
 then $a_{ij} = |L_i \cap L_j|$.
 If the pair does not have an equal descendant sample set then we set $a_{ij}=0$.
 Matrix $A$ determines the \textit{best match} for every node $i\in N_{T_1}$
 via looking at the maximum in row $i$, $\alpha_i = \max_{j\in N_{T_2}} a_{ij}$.
 If this maximum is not unique, we use time difference to determine the best match pair.
 We then define the \textit{discrepancy} between $\T_1$ and $\T_2$ as 
 one minus the proportion of sum of the shared spans divided by the total node span of $\T_1$.
 
 We note that the discrepancy function is a metric for detecting non-similarity between two tree sequences. However, we note that this function is not a metric in the mathematical sense, as it is not symmetric, nor is it reflexive. For example, given a tree sequence $\T$ and its simplification $\mathbb{S}$ and $\T\neq\mathbb{S}$ we have $\operatorname{discrepancy}(\mathbb{S}, \T)=0$. Additionally, given \figref{fig:conceptual_discrepancy}, $\operatorname{discrepancy}(T1, T2) \neq \operatorname{discrepancy}(T2, T1)$ \comment{actually compute this. We may just do it in this section instead of the appendix?}
 
\comment{Do we want a complete walkthrough of Figure 3? Could be useful in an appendix} 

\begin{figure}[!ht]
	\begin{center}
\includegraphics[height=1.5in, width=3in]{discrepancy_func_method_t1.pdf}
\includegraphics[height=1.5in, width=3in]{discrepancy_function_method_t2.pdf}
    \caption{
        For two tree sequences $T1$ and $T2$ the \textit{discrepancy function}, $d(T1,T2)$, matches nodes in $T1$ with nodes in $T2$
        based on identical sample sets. We then measure each pair of nodes' \textit{shared span} across the entire tree sequence.
        In this example we have nodes $0$ through $7$ in $T1$ match with their identical counterpart. 
        Node $8$ has no match in $T2$ as there are no nodes in $T2$ with sample set $\left\{1,2,3\right\}$.
        \comment{make some reference to Discrepancy function section or appendix for more in depth calculation.}
        \label{fig:conceptual_discrepancy}
    }
	\end{center}
\end{figure}
 
 \begin{algorithm2e}[!ht]
 \SetStartEndCondition{ }{}{}%
 \SetKwProg{Fn}{def}{\string:}{}
 \SetKwFunction{Range}{range}%%
 \SetKw{KwTo}{in}
 \SetKwFor{For}{for}{\string:}{}%
 \SetKwIF{If}{ElseIf}{Else}{if}{:}{elif}{else:}{}%
 \SetKwFor{While}{while}{:}{fintq}%
 \SetKw{Break}{break}
 \newcommand\forcond{$i$ \KwTo\Range{$n$}}
 \SetKwComment{Comment}{}
 \AlgoDontDisplayBlockMarkers\SetAlgoNoEnd\SetAlgoNoLine%
 \DontPrintSemicolon\LinesNotNumbered
 
 \caption{Discrepancy Function}\label{alg:disc}
 \input{$(T_1,T_2)$}
 \output{tree discrepancy, root-mean-square error}
 
 \Fn{Shared Spans($T_1,T_2$)}{
 \For{pairs $(i,j)\in N_{T_1}\times N_{T_2}$}{
 	$i = (t_i, L_i)$ and $j = (t_j, L_j)$ where $L_i, L_j\subset \left[0,L\right).\quad$ \Comment{Each node is a tuple (time, genome location).}
 	\If{$(i,j)$ has equal sample sets, $s(i)=s(j)$}{
 		Define $a_{ij}=|L_i\cap L_j|$.
 	}
 	\Else{Define $a_{ij}=0$.}
 Define matrix $A=\left[a_{ij}\right]\in M_{N_{T_1}\times N_{T_2}}(\R)$.\;
 }
 \KwRet{$A$}
 }
\BlankLine
\Fn{Discrepancy ($T_1,T_2$)}{
\For{each node $i\in N_{T_1}$}{
	Find nodes in $N_{T_2}$ which have the highest matching span.\;
	$\operatorname{matches}_i = \argmax_{k\in N_{T_2}} a_{ik}.$\;
	Let $j = \argmax_{k\in \operatorname{matches}_i}\frac{1}{1+|t_i-t_k|}$.\;
	Define $\alpha_i = a_{ij}$.\;
	\BlankLine
}
$$tree\ discrepancy = 1 - \frac{\sum_{i\in N_{T_1}} \alpha_i}{\operatorname{tr}\left(Shared Spans(T_1, T_1)\right)}$$\;
\BlankLine\BlankLine
$$rmse = \sqrt{\frac{\sum_{i\in N_{T_1}}|t_i - t_j|\alpha_i}{\operatorname{tr}\left(Shared Spans(T_1,T_1)\right)}}$$\;
\BlankLine
$$true\ proportion = \frac{\sum_{i\in N_{T_1}} \alpha_i}{\operatorname(tr)\left( Shared Spans(T_2, T_2)\right)}$$\;
\BlankLine\BlankLine
\KwRet{tree discrepancy, rmse, true proportion}
}
\end{algorithm2e}


\section{Results}

\comment{
    Idea: look at statistical properties of unary regions:
    look at how much 'unary regions' there is in simulation
    and how much we can put back in,
    as a function of time.
}

%% TO DO:
%% 1. Discuss trapped unary spans more
%% 2. Discuss the comparison between tsinfer and extend haplotypes
%% 3. Add more figures 
%%	- (Edge counts between tsinfer and extend haplotypes)
%%	- Average Edge counts per iterations
%% 4. Discuss figures about total edge span added in both recombination and gene conversion events
%% 5. Discuss the figures on edge reduction (include #3 part 1.)

When observing our algorithm, we have to observe that for general tree sequences that have been initially simplified, there are portions of the tree sequence that the extend haplotypes method will not be able to recover. We call these portions \textit{trapped unary spans}. Most of these spans occur in the oldest portions of the ancestry near roots of the tree sequence. Thus we must disregard these unary spans when observing the effects of extend haplotypes.
First we have to determine how much of a tree sequence is trapped?
For a tree sequence $\T$ simulated in `msprime` with genomic length $5\times 10^7$ with 1000 samples, recombination rate $10^{-8}$ and population size $10^4$, we found that trapped unary spans represented 49\%.
This means that extend haplotypes can only affect 51\% of this tree sequence.
When we apply our algorithm to the simplified given tree sequence, the ratio of unary span bordering coalescing between the extend tree sequence and the original is 0.4917. This means that \comment{something something something...}  
See \figref{fig:correct-unary-span-log}, \figref{fig:correct-unary-span}, \figref{fig:node-spans}.


%$msprime.sim_ancestry(1000, sequence_length=5e7, recombination_rate=1e-8, population_size=1e4, coalescing_segments_only=False, random_seed=1)$
%From the above output we see that ratio of unary span bordering coalescing between 
%- ExtendPaths/Truth = 0.4917
%- ExtendEdges/Truth = 0.27828
%
%The trapped unary span of our ground truth is 49\% of the TS.
%
%Total unary span bordering coalescing: 255151996720.0 (51.0\%)
%Total trapped unary span: 245038231157.0 (49.0\%)
%Total coalescing span: 99950000000.0
%Total unary span bordering coalescing: 125466159245.0 (100.0\%)
%Total trapped unary span: 0.0 (0.0\%)
%Total coalescing span: 99950000000.0

\begin{figure}[bht]
	\includegraphics[width=0.9\linewidth]{newplots_wo_ee/node_spans_wo_trapped_unary_regions.pdf}
	\caption{Node spans of simulated tree sequence (blue), simplified tree sequence (green), and extended tree sequence (red).}
	\label{fig:node-spans}
\end{figure}

\begin{figure}[bht]
	\includegraphics[width=0.9\linewidth]{newplots_wo_ee/better_unary_spans_ep_log.pdf}
	\caption{Correct Unary Span for Extend Haplotypes (log)}
	\label{fig:correct-unary-span-log}
\end{figure}

\begin{figure}
	\includegraphics[width=0.9\linewidth]{newplots_wo_ee/better_unary_spans_ep_notlog.pdf}
	\caption{Correct Unary Span for Extend Haplotypes}
	\label{fig:correct-unary-span}
\end{figure}

\begin{figure}
%	\includegraphics[width=0.9\linewidth]{newplots_wo_ee/avg_edge_count_over_iters_5e7_1000s.pdf}
	\caption{The average number of edges for an extended tree sequence per iteration of the extend haplotypes algorithm.}
	\label{fig:edges-per-iteration}
\end{figure}

% (AVA)
% * reduction in edges ~ sequence length
% * speed increase ~ sequence length
% * proprotion of added edges that are true ~ sequeence length

%\begin{figure}
%	\includegraphics[width=0.9\textwidth]{newplots_wo_ee/simp_vs_ext_tajimasD_runtime_numtrees.pdf}
%    \caption{
%        Two-part figure, showing reduction in number of edges (left) and increase in speed of stats comptuation (right)
%        as a function of number of trees (modulated by sequence length),
%        on reasonably big simulated sequences.
%        For "speed": plot ratio of runtime before/after extending.
%        \label{fig:speed_and_edges}
%    }
%\end{figure}

%Simple experiment:
%(1) simulate, simplify, and extend;
%(2) let $x$ be total matching span of simplified tree (here equal to the total span); $y$ total matching span of extended tree in truth and $z$ total not-matching span;
%then $z$ is "total wrongly added stuff" and $y-x$ is "total rightly added stuff".
%
%With tsinfer: (1) simulate and tsinfer; (2) do the above either with or without simplifying the tsinfer'ed trees.
%(but also take into account that there's wrong stuff in tsinfer'ed tree: look at whether it reduces discrepancy!)

\begin{figure}
	\begin{center}
		\includegraphics[width=0.9\linewidth]{newplots_wo_ee/discrepancy_over_sample_5e7_new.pdf}
		\caption{Left: Discrepancy \newline Right: True Proportion }
	\end{center}
	\label{fig:discrepancy-over-sample}
\end{figure}

\begin{figure}
	\begin{center}
		\includegraphics[width=0.9\linewidth]{newplots_wo_ee/discrepancy_over_seqlen_1000s_new_5e7.pdf}
		\caption{Left: Discrepancy \newline Right: True Proportion}
	\end{center}
	\label{fig:discrepancy-over-seqlen}
\end{figure}

\begin{figure}
	\includegraphics[width=0.9\linewidth]{newplots_wo_ee/SL_vs_Num_edges_subplot.pdf}
	\includegraphics[width=0.9\linewidth]{newplots_wo_ee/edge_reduction_prop_vs_SL.pdf}
    \caption{
        Maybe: summaries of lengths and/or numbers of correctly and incorrectly added edges?
        (See notebook.)
        \label{fig:results_edges}
    }
\end{figure}

\begin{figure}
	\includegraphics[width=0.9\linewidth]{newplots_wo_ee/sampling_dist_geneconversion.pdf}
	\caption{Observation of Extendhapltypes with gene conversion = some number
	Left: 
	Middle:
	Right: }
\end{figure}

\begin{figure}
	\includegraphics[width=0.9\linewidth]{newplots_wo_ee/sampling_dist_recomb.pdf}
	\caption{Observation of Extendhapltypes with recombination = some number
		Left: 
		Middle:
		Right: }
\end{figure}

\subsection{Data}
% * 1. Simulate data
% * 2. Run tsinfer
% * 3. Compare d(x,truth) for x in tsinfer, tsinfer+add edge, tsinfer+add edge + simplify, tsinfer+simplify

% * How much unary edges?
% * How much can we add?

% * apply to real data:
%     - % fewer edges
%     - % fewer distinct ancestors (ancestral paths?) of sample at some time

\section{Discussion}

TODO

\bibliography{references}

\appendix
%
%\begin{figure}
%    \caption{
%        Supplementary figure: runtime of discrepancy function as a function of number of trees
%        (which we modulate by changing sequence length).
%        \label{fig:speed_discrepancy}
%    }
%\end{figure}

\end{document}
