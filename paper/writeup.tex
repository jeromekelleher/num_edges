\documentclass{article}
\usepackage{fullpage}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{natbib}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{tikz}
\usetikzlibrary{arrows, snakes,backgrounds}
\tikzstyle{place}=[circle,draw=black,thick, inner sep=0pt, minimum size = 5mm]

\SetKwInput{input}{Input}
\SetKwInput{output}{Output}

\newcommand{\E}{\mathbb{E}}
\renewcommand{\P}{\mathbb{P}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\tn}{\textnormal}
\newcommand{\ov}{\overline}

\begin{document}


% Name ideas:
% 
% extend edges
% bundle edges
% inflate edges
% bundle lines of descent
% longer ancestral haplotypes
% inflated ancestors
% compress paths
% optimizing edge tables
% reduce number of ancestors
% reduce ancestral paths

\section{Introduction}

% PETER
% * what's a tree sequence
% * why is a tree sequence (motivation)

The pedigree that describes how everyone of some species
are related to each other
is a large graph, where nodes are indexed by time.
Within this, one can trace back the paths along which segement of genome
have been inherited.
The \emph{succinct tree sequence} (or, tree sequence for short)
was introduced by \citet{kelleher2016efficient} to describe the subset of these paths
along which the genome of a sample of individuals was inherited.


\section{Motivation and statement of problem}

% PETER
% * minimize number of edges
% * gives extra info about shared haplotypes, reduces number of ancestral paths


\section{Algorithm}

% * description (HALLEY)
% * proof of something:
%     - arrives at a local minimum?
%     - guess at typical reduction?

\subsection*{Notation}
    We begin with some notation. We define a \textit{tree sequence}, denoted $TS$, 
    as a tuple $\left( \left\{T_k\right\}, N, E, L\right)$ where
     $\left\{T_k\right\}_{k=1}^n$ is the set of trees,
     $N$ and $E$ are the sets of nodes and edges respectively,
     and $L=[0,a)\subseteq \R$ is the length of the sequence on the genome.
     The length of each tree $T_k$ is some subinterval $[a_k,a_{k+1})$ 
     with the lengths of consecutive trees in the sequence 
     only intersecting each intervals endpoints. 
    Additionally, a node $x\in N$ is \textit{unary} if it only has one child, 
    ie. only a single edge extending below it on the tree.
    With these tree sequences our goal is to
    minimize the number of edges
    as well as infer coalescence of genes. 
    To remove edges we consider the following example.
    Suppose for a tree $T_k$ in the tree sequence $TS$ 
    there exists a branch which contains a unary node $b\in N$.
    Then the node $b$ has one parent, $a\in N$, 
    and one child $c\in N$,
    each with edges $e_{ab}, e_{bc}\in E$ connecting them.
    If there is an edge between the nodes $a$ and $c$ in trees 
    $T_{k+1}$ (or $T_{k-1}$),
    then we wish to extend the edges $e_{ab},e_{bc}$ 
    to $T_{k+1}$ and then remove the edge $e_{ac}$ from $T_{k+1}$. 
    This action reduces the length of the edge $e_{ac}$ on the genome,
    and in some cases, completely removes the edge. 
    We now perform this action on all such unary nodes 
    over the entire tree sequence.
\begin{center}
\begin{tikzpicture} 
	\node[circle,draw,inner sep=1pt] (a) at (0,2) {a}
	[growth parent anchor=south] 
		child { node[circle,draw,inner sep=1pt] {b} 		
	 			child {
	 				node[circle,draw,inner sep=1pt] (c) at (0,0) {c}
	 					child{node (d) at (0,1) {$T_k$}
	 						edge from parent [draw=none]}
	 				edge from parent 
	 					node[left] {$e_{b,c}$}
	 			}	 		
	 		edge from parent
	 			node[left] {$e_{a,b}$}
	 	};
 	
	 	
	\node[circle,draw,inner sep=1pt] (a') at (3,2) {a}
	[growth parent anchor=south]
		child {
			child{
				node[circle,draw,inner sep=1pt] (c') at (0,-0.25) {c}	
					child{node (d) at (0,1) {$T_{k+1}$}
						edge from parent [draw=none]}
			}
			node[left] {$e_{a,c}$}
		};	
	
	\node at (6,0) {$\Longrightarrow$};
	\node at (6,0.5) {\tn{Edge Extend}};
	
	\node[circle,draw,inner sep=1pt] (a''') at (9,2) {a}
	[growth parent anchor=south] 
	child { node[circle,draw,inner sep=1pt]	 {b}	
		child {
			node[circle,draw,inner sep=1pt] (c) at (0,0) {c}
			child{node (d) at (0,1) {$T_k$}
				edge from parent [draw=none]}
			edge from parent 
			node[left] {$e_{b,c}$}
		}
		edge from parent
		node[left] {$e_{a,b}$}
	};

	\node[circle,draw,inner sep=1pt] (a'v) at (12,2) {a}
	[growth parent anchor=south] 
	child { node[circle,draw,inner sep=1pt] {b}		
		child {
			node[circle,draw,inner sep=1pt] (c) at (0,0) {c}
			child{node (d) at (0,1) {$T_{k+1}$}
				edge from parent [draw=none]}
			edge from parent 
			node[left] {$e_{b,c}$}
		}
		edge from parent
		node[left] {$e_{a,b}$}
	};
	
	
\end{tikzpicture}
\end{center}
    In more detail, let $TS = \left( \left\{T_k\right\}_{k=1}^n, N, E, L\right)$ 
    be a tree sequence.
    Within tskit we can track a tree sequence using a function called `EdgeDiffs'.
    This function tracks edges which are removed and added 
    between consecutive trees in the sequence. 
    As in \ref{} (tikzfigure), we can track if 
    $e_{a,b}$ and$e_{b,c}$ were removed from $T_k$ 
    when creating $T_{k+1}$, 
    and we can see if $e_{a,c}$ was just added in $T_{k+1}$.


\begin{algorithm}[!ht]  % How 'code-like' do we want the algorithm to be? Do we want to keep a lot of the syntax in layman's terms or do we want to use functions like ts1.coiterate(ts2)??
	
\SetStartEndCondition{ }{}{}%
\SetKwProg{Fn}{def}{\string:}{}
\SetKwFunction{Range}{range}%%
\SetKw{KwTo}{in}
\SetKwFor{For}{for}{\string:}{}%
\SetKwIF{If}{ElseIf}{Else}{if}{:}{elif}{else:}{}%
\SetKwFor{While}{while}{:}{fintq}%
\SetKw{Break}{break}
\newcommand\forcond{$i$ \KwTo\Range{$n$}}
\AlgoDontDisplayBlockMarkers\SetAlgoNoEnd\SetAlgoNoLine%

\caption{Extends edges across a tree sequence $TS$.}\label{alg:edge}
\SetKwFunction{ex}{Extend Edges}
\SetKwFunction{fwd}{Forward Extend}
\DontPrintSemicolon
\LinesNotNumbered
%\SetAlgoNoEnd
\input{A tree sequence $TS$}
\output{New tree sequence,$TS'$, with reduced number of edges}

\BlankLine 

\Fn{\fwd (tree sequence $TS$, forwards = \tn{True})}{
{	
\eIf{forwards=\tn{True}}{EdgeDiffs $\gets TS$.edgediffs()\BlankLine}
{\BlankLine
	EdgeDiffs $\gets$ reversed($TS$.edgediffs())\;}
}
\Indm \For{(Interval, EdgesOut, EdgesIn) \KwTo EdgeDiffs}{
	\For{e1 \KwTo EdgesOut}{
		\For{e2 \KwTo EdgesOut}{
			\If{e2.parent = e1.child}{
				\For{e3 \KwTo EdgesIn}{
					\If{e3.parent=e1.parent \tn{AND} e3.child=e2.child}{
						e1.right $\gets$ Interval.right\;
						e2.right $\gets$ Interval.right\;
						e3.left $\gets$ Interval.right\;
						\If{e3.left = e3.right}{
							$E$.remove(e3)\;
							}}}}}}}\;
$TS'\gets TS$.update()\;						
\KwRet{$TS'$}\;
}
\BlankLine						
\Fn{\ex ($TS$, iter=100)}{
	edges $\gets$ $TS$.numedges()\;
	\BlankLine
	\For{$*$ \KwTo \Range(iter)}{
		$TS' \gets TS$.\fwd(fowards=\tn{True})\;
		$TS' \gets TS$.\fwd(fowards=\tn{False})\;
		\eIf{$TS$.numedges = edges}{
			\Break\BlankLine}
		{edges $\gets$ $TS'$.numedges()\;}
		}
}
\KwRet{$TS'$}\;
\end{algorithm}

With this algorithm we only extend existing edges
over a larger interval on the genome,
and remove unnecessary edges in the process.
%% Find counter example to global minimum.

\section{Results (how it works)}

% (AVA)
% * reduction in edges ~ sequence length
% * speed increase ~ sequence length
% * proprotion of added edges that are true ~ sequeence length
% * apply to real data:
%     - % fewer edges
%     - % fewer distinct ancestors (ancestral paths?) of sample at some time

\section{Discrepancy Function}
% * How to measure agreement that includes haplotypes
% * Definition and Algorithm
% * Supp fig: runtime ~ # trees, samples
% * fig: how add edges rueduces discrepancy
%       - compare to Relate and tsinfer
% * Show: how add edges reduces discrepancy
% * THINK of a way to asynchronously computing discrepancy

\par Now with an algorithm in place
 we need a metric to discern
 if trees modified with edge extend
 in fact correctly infer haplotypes in our original tree sequence.
 We have thus constructed a function which counts the differences 
 between trees on a pair of tree sequences. 
 To count all the discrepancies we must begin by counting differences for each node in the tree sequence.
 
 Let $TS^1=(\{T_i^1\},N^1,E^1,L^1)$ and $TS^2=(\{T^2_j\},N^2,E^2,L^2)$ be tree sequences.
 Suppose that $x\in N^1$ and $y\in N^2$ are nodes in each tree sequence.
 We denote the \textit{set of descendant samples} of $x$ at position $i$ in the genome as $D_{TS^1}(x,i)$.
 Now for a pair of nodes $(x,y)\in TS^1\times TS^2$ 
 we can measure how much they agree along the genome.
 We do so with the following function
 $$\rho_{(TS^1,TS^2)}(x,y)=\frac{1}{L}\sum_{i=0}^{L-1}[D_{TS^1}(x,i)=D_{TS^2}(y,i)],$$
 where $L=\min\{L^1,L^2\}$ and $[\cdot]$ is the characteristic function. 
 We see $\rho$ measures the fraction of the tree sequence
 along which $x$ and $y$ have exactly the same descendant set. 
 For each node $x\in N^1$ we can use $\rho$ to find its global best matching node $y\in N^2$. 
 This node $y$ should not just be a maximum of $\rho(x,\cdot)$ but it should also have a branch length similar to $x$. 
 This means our node $y$ should minimize both $|t_x-t_y|$ and $1-\rho_{(TS^1,TS^2)}$.
 We then use this $y$ to find count the length of genome which $x$ differs from its best matching node in $TS_2$ with the function
 $$\hat{d}(x,TS^1,TS^2)=\min_y\{|t_x-t_y|(1-\rho_{(TS^1,TS^2)}(x,y))\}.$$
 Here $t_x$ and $t_y$ denote the time of occurrences (ie. branch length) for nodes $x$ and $y$. 
 The function $\hat{d}$ measures the proportion of the genome 
 over which the descendant set of $x$ differs from its best matching node $y$.
 We can now extend this from any node $x\in N^11$ to all of $TS_1$ with the \textbf{discrepancy function}
 $$d(TS_1,TS_2)=\sum_{x\in N_1}\hat{d}(x,TS_1,TS_2).$$
 This function, as we will see in the algorithm below,
 is $|N^1||\{T^1\}|$ as for each tree in $TS_1$ and each node $x\in N^1$ we only need to look at $O(1)$ nodes rather than all nodes in $N^2$.
 



\begin{algorithm}[!ht]
\SetStartEndCondition{ }{}{}%
\SetKwProg{Fn}{def}{\string:}{}
\SetKwFunction{Range}{range}%%
\SetKw{KwTo}{in}
\SetKwFor{For}{for}{\string:}{}%
\SetKwIF{If}{ElseIf}{Else}{if}{:}{elif}{else:}{}%
\SetKwFor{While}{while}{:}{fintq}%
\SetKw{Break}{break}
\newcommand\forcond{$i$ \KwTo\Range{$n$}}
\SetKwComment{Comment}{}{} 
\DontPrintSemicolon
\LinesNotNumbered
\AlgoDontDisplayBlockMarkers\SetAlgoNoEnd\SetAlgoNoLine%


\input{$(TS_1,TS_2)$}
\output{discrepancy number (some float value)}

\Fn{Node Discrepancy($x,TS_1,TS_2$)}{
$s=0\in \mathbb{Z}^{|N^2|}$ \Comment*[f]{Similarity vector with each entry corresponds to a node in $TS_2$}

\For{$I$, $T^1_k$, $T^2_j$ \KwTo $(L,TS_1,TS_2)$}{
\Comment{Here $I=[a^1_k,a^1_{k+1})\cap [a^2_j,a^2_{j+1})$ is the interval which the two trees $T^1_k$, $T^2_j$ both span over. Here we find the best matching node $y$.}
$D_{T^1_k}(x)\gets D_{TS^1}(x,i)$ where $i\in I$\;
\If{$|D_{T^1_k}(x)| > 0$}{
\If{$|D_{T^1_k}(x)|=1$}{
$y \gets D_{T^1_k}(x)$\;
$m \gets D_{T^1_k}(x)$\;}
\Else{$m \gets $ most recent common anscestor of $D_{T^1_k}(x)$ in $T^1_k$\;
$y\gets $ most recent common anscestor of $D_{T^1_k}(x)$ in $T^2_j$\;}}
\If{$D_{T^2_j}(y)=D_{T^1_k}(x)$}{
$s_y\gets s_y$\;}}
\KwRet{node discrepancy}\;}
\Fn{Discrepancy($TS_1,TS_2$)}{
discrepancy = 0\;
\For{$x\in N^1$}{discrepancy = $\sum_{x\in N^1}{$Node Discrepancy($x,TS_1,TS_2$)}}
\BlankLine
\KwRet{discrepancy}}
\caption{Discrepancy Function}\label{ndisc}
\end{algorithm}

\section{Data}
% * 1. Simulate data
% * 2. Run tsinfer
% * 3. Compare d(x,truth) for x in tsinfer, tsinfer+add edge, tsinfer+add edge + simplify, tsinfer+simplify

% * How much unary edges?
% * How much can we add?

\bibliography{references}

\end{document}
