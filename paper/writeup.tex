\documentclass[10pt,twoside,lineno]{gsajnl}
\articletype{inv} % article type

\usepackage[dvipsnames]{xcolor}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{natbib}
\usepackage[linesnumbered,ruled,vlined,algo2e]{algorithm2e}
\usepackage{tikz}
\usetikzlibrary{arrows, snakes,backgrounds}
\tikzstyle{place}=[circle,draw=black,thick, inner sep=0pt, minimum size = 5mm]
\usepackage{hyperref}
\hypersetup{
	pagebackref=true,
	colorlinks = true,
	allcolors = OliveGreen}

\SetKwInput{input}{Input}
\SetKwInput{output}{Output}


\newcommand{\E}{\mathbb{E}}
\renewcommand{\P}{\mathbb{P}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\T}{\mathbb{T}}
\newcommand{\ind}{\mathbf{1}}
\newcommand{\tn}{\textnormal}
\newcommand{\ov}{\overline}
\newcommand{\tskit}{\texttt{tskit}}
\newcommand{\tsinfer}{\texttt{tsinfer}}
\newcommand{\msprime}{\texttt{msprime}}
\newcommand{\argmax}{\operatorname{argmax}}
\newcommand{\dis}{\operatorname{dis}}
\newcommand{\similarity}{\operatorname{sim}}
\newcommand{\comment}[1]{{\color{violet} \it #1}}

\newcommand{\algorithmref}[2][]{%
	\hyperref[{#2}]{%
		Algorithm~\ref*{#2}%
		\ifx\\#1\\%
		\else
		\,#1%
		\fi
	}%
}

\newcommand*{\figref}[2][]{%
	\hyperref[{#2}]{%
		Figure~\ref*{#2}%
		\ifx\\#1\\%
		\else
		\,#1%
		\fi
	}%
}




\title{
    A forest is more than its trees:
    haplotypes and inferred ARGs
}

% Information in recombination junctions can both compress and improve inferred tree sequences
% Non-coalescing regions of dark matter in ARGs
% Can we find them? Are they useful in inference, dating? 
% Look, we can find them and they seem at least useful for compression.
% Also, here's a way of measuring agreement that takes this sort of thing into account,
%  which extends R-F to measure haplotypes


% NOTE: these are in alphabetical order for now; we can revisit that ordering
\author[$\dagger$]{Halley Fritze}
\author[$\dagger$]{Nathaniel Pope}
\author[$\dagger$]{Ava Bamforth}
\author[$\ddagger$]{Jerome Kelleher}
\author[$\ast$,$\dagger$,S]{Peter Ralph}

\affil[$\ast$]{Institute of Evolution and Ecology and Department of Biology, University of Oregon, Eugene, Oregon}
\affil[$\dagger$]{Department of Mathematics, University of Oregon, Eugene, Oregon}
\affil[$\ddagger$]{Big Data Institute, Li Ka Shing Centre for Health Information and Discovery, University of Oxford}
\affil[$\S$]{Department of Data Science, University of Oregon, Eugene, Oregon}


\keywords{genealogy, tree sequence, haplotypes}

\runningtitle{Junctions in tree sequences}
\runningauthor{Bamforth \textit{et al.}}

%%%%%%%%%%
\begin{abstract}
    Foreshadowing haplotype-based methods of the genomics era,
    it is an old observation that the ``junction'' between two distinct haplotypes
    produced by recombination is inherited as a Mendelian marker.
    In this paper, we describe how this recombination-mediated information
    can in many cases be recovered from inference based solely on
    polymorphic markers (i.e., information produced by mutation),
    which produces unary nodes along the branches of the marginal genealogical trees.
    The resulting inferred ARGs, represented as tree sequences,
    are smaller, faster to compute with,
    and potentially contain substantially more information
    about the age of ancestral haplotypes,
    than inferred ARGs without these unary nodes.
    We provide efficient algorithms to identify this ancestral haplotype information,
    new metrics of agreement/disagreement between inferred ARGs,
    and explore some consequences for ARGs inferred from real data.
\end{abstract}

\begin{document}

\maketitle
\thispagestyle{firststyle}
\marginmark
\firstpagefootnote

\correspondingauthoraffiliation{1}{Corresponding author: {plr@uoregon.edu}}
\vspace{-33pt}% Only used for adjusting extra space in the left column of the first page


%%% OUTLINE
% Intro: haplotypes, unary bits of non-coalescing nodes, ARGS, etcetera
%    explain what tsinfer does to create unary regions
%    statement of problem
%    Yan: are breakpoints in true->simplify->extend the same as in original?
%   Fig 1: conceptual figure
%    Also IBD gets screwed up
% 
% Methods:
%   edge extend algorithm
%   discrepancy funciton algorithm
%   Fig 2: Conceptual figure for discrepancy
% 
% Results:
%   Fig 3:
%     (a) reduction in number of edges and (b) speed change
%
%   Fig 4:
%     Histograms of (a) total span added, (b) percent incorrect
%
%   Fig 5 and maybe 6: how it interacts with tsinfer
%     (a) summarize total matching and unmatching span (or maybe percent matching?)
%           across reps
%     (b) discrepancy per node against depth or time or number of subtended samples
%        describe percent span matched against true span or depth or something
%
%   Fig 7(?): compare IBD stats before/after
% 
% Supp:
%   S1: runtime
%%%


% Name ideas:
% 
% extend edges
% bundle edges
% inflate edges
% bundle lines of descent
% longer ancestral haplotypes
% inflated ancestors
% compress paths
% optimizing edge tables
% reduce number of ancestors
% reduce ancestral paths


%%%% COLOR SCHEME FOR FIGURES %%%%
% colors = {'blue': 'rgb(46,37,133)',
%	'red': 'rgb(194,106,119)',
%	'lgreen': 'rgb(93,168,153)',
%	'gold': 'rgb(220,205,125)',
%	'green': 'rgb(51, 117,56)',
%	'lblue': 'rgb(148,203,236)',
%	'magenta': 'rgb(159,74,150)',
%	'wine': 'rgb(126,041,084)', 
%}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

% PETER
% * what's a tree sequence
% * why is a tree sequence (motivation)

There has been substantial recent progress
in the problem of ``ARG inference'',
which seeks to infer (portions of) the ``ancestral recombination graph'' (or, ARG)
that describes how a set of genotypes samples are related to each other
at each position of the genome \citep{speidel2019method,kelleher2019inferring,zhang2023biobankscale,deng2024robust,lewanski2024introduction}.
One way of viewing the ARG is as a sequence of ``marginal trees'',
i.e., the genealogical trees that describe how each portion of the genome
was inherited by the focal genomes.
This is reflected in methodology of some ARG inference methods \citep[e.g., Relate][]{speidel2019method},
in metrics used to assess inference accuracy \citep{XXX},
as well as in basic terminology.
For instance, 
the ``succinct tree sequence'',
introduced by \citet{kelleher2016efficient},
is a common format for describing these inferred ARGs,
and is seeing wide use thanks in part to its efficiency and accompanying reliable toolkit,
\tskit \citep{XXX}.

However, the ARG is emphatically not merely a sequence of trees:
viewed another way, it describes inheritance relationships between ancestral haplotypes.
These two points of view are related because a single haplotype
may extend over many marginal trees;
in other words, the internal nodes in the trees are labeled, and many of these labels
are shared between adjacent trees.

Another reason we tend to focus on the trees is that
much of our intuition about inference of relationships from genomic data
comes from phylogenetics.
Indeed, all methods might very roughly be summarized as
``more similar sequences are more closely related''.
For instance, two sequences that share a drerived mutation
are (probably) more closely related over some span of genome surrounding the location where the mutation occurs.
It has long been observed 
that not only mutations
but also the ``junctions'' between distinct haplotypes,
if they could be somehow identified,
would be inherited as Mendelian markers
\citet{fisher1954fuller,chapman2003model}.
In more modern terminology, 
even in the absence of new mutations,
recombination between distinct haplotypes can create a novel haplotype
whose relationships and origination time could be inferred.

Haplotype identity has been nearly overlooked in the literature on ARG inference so far --
all metrics that have been used so far to measure accuracy of inferred ARGs
depend only on the sequence of marginal trees,
not on sharing of ancestral haplotype identities between them.
Suppose two methods are used to infer ARGs from the same set of genotyped samples.
Although both ARGs describes relationships between many haplotypes,
only those haplotypes that represent the focal set of genotyped samples
can be unambiguously said to represent the same thing in both.
So, most metrics only describe these relationships,
which ignores the additional information carried by the structure of other haplotypes.
For instance, \citet{kelleher2019inferring} and \citet{zhang2023biobankscale}
compared true and inferred ARGs
using average Robinson-Foulds and Kendall-Colijn distances between trees
across a regular sequence of genomic positions,
using sampled genotypes as labels,
while \citet{brandt2022evaluation} compared times to most recent common ancestor
between pairs of sampled genomes.
Neither is affected by shared haplotype structure -
two ARGs could be identiical by either measure
but have completely different identity by descent (IBD) segment structure
(as defined in the context of the ARG, \citep{XXX}).
\citet{deng2021distribution} evaluated agreement of distributions of
distances along the genome between tree topology changes,
and \citet{zhang2023biobankscale} defined a generalization of Robinson-Foulds distance
that is the total variation distance between the induced distribution on genotypes;
neither of which measure sharing of haplotypes between adjacent trees.

In this paper, we study various aspects of haplotype identity in ARGs.
First, we describe a deterministic algorithm that
extends the span over which ancestral haplotypes extend
using the principle that intermediate nodes in inheritance paths
should remain unchanged when possible.
These extended ancestral haplotypes manifest as unary nodes in the marginal trees.
To quantify how accurate the new information is,
we define and describe how to compute new measures of (dis-)agreement between ARGs
that are motivated by the XXX distance between trees
but account for haplotype identity.
These measures show that the vast majority of these extended haplotypes are correct,
and that substantial information about haplotypes is contained in these nodes
in inferred trees as well.


\subsection{Motivation and statement of problem}

% PETER
% * minimize number of edges
% * gives extra info about shared haplotypes, reduces number of ancestral paths

Consider the (small portion) of a hypothetical tree sequence in \figref{fig:conceptual}A.
On the first portion of the genome (left-hand tree), the sample nodes (labeled 0, 1, and 2)
coalesce into a small subtree: 1 and 2 find a common ancestor in ancestral node 3,
which finds a common ancestor with node 0 in ancestral node 4.
On the next portion of the genome (right-hand tree), sample node 2 has a different ancestor.
This seems reasonable, and a method that infers trees separately on each portion of the genome
could not be expected to produce anything different.
However, things change once we think about what this implies about haplotype inheritance.
\figref{fig:conceptual}B shows the implied inheritance of haplotypes,
with the haplotypes carried by 4 to the left and right of the recombination breakpoint labeled $L$ and $R$.
Here, sample node 2 has inherited the chunk of haplotype labeled $L$ from ancestral node 4 via 3,
and the haplotype to the right of this from some other node (and so doesn't carry haplotype $R$).
On the other hand, sample node 1 has inherited \emph{both} haplotypes $L$ and $R$
from ancestral node 4, but the trees imply that only haplotype $L$ is inherited via ancestral node 3.
This implies -- if taken literally -- that there must have been a recombination event
at some point between node 1 and node 4 that separated the $L$ and $R$ haplotypes,
and then these two ancestral (and nonoverlapping) haplotypes coalesced together in ancestral node 4.
Although this is possible, it seems unlikely --
a more parsimonious explanation is depicted in \figref{fig:conceptual}C,
in which sample node 1 inherits the entire $LR$ haplotype from ancestral node 4 through node 3
(and there is a recombination somewhere between node 3 and node 2).
This implies that ancestral node 3 inherits from node 4 on the right-hand tree as well,
which is depicted in \figref{fig:conceptual}D --
and so node 3 has become unary in this tree.
Note that the more parsimonious tree sequence also includes fewer edges:
the three distinct edges $4 \to 3$, $3 \to 1$, and $4 \to 1$ in \figref{fig:conceptual}B
have been reduced to the two edges
$4 \to 3$ and $3 \to 1$ in \figref{fig:conceptual}D.

So, given the ARG shown in \figref{fig:conceptual}A\&B,
it should be possible to extend the ancestral haplotype represented by node 3
to obtain the ARG shown in \figref{fig:conceptual}C\&D,
thus adding additional information to the ARG.
This might be surprising,
as intuition from phylogenetics suggests we can only infer
information about the branching points in the tree, not intermediate (unary) nodes.
The goal of this paper is to answer:
How can we do this, and how accurate is the resulting inference?

\begin{figure}
    \begin{center}
    \includegraphics[width=0.9\textwidth]{conceptual_figure.pdf}
    \end{center}
    \caption{
        A simple example showing the basic idea
        (described in more detail in the text):
        \textbf{(A)} a small portion of a tree sequence without unary nodes;
        \textbf{(B)} the implied inheritance pattern of the two portions of the haplotype carried by ancestral node 4,
        labeled $L$ and $R$;
        \textbf{(C)} marginal trees with a unary node added,
        which produces \textbf{(D)} a more parsimonious haplotype inheritance pattern
        (that also includes fewer edges).
        \label{fig:conceptual}
    }
\end{figure}

%\subsection{Extend Edges}
%	\comment{Should we keep a brief section about the original extend edges? If yes, some notes are below.}
%    We do so by identifying short paths (2 edges) in a tree.
%    If neighboring trees contain edges with 
%    identical ancestor (parent) and descendant (child) nodes, 
%    we assume that there is implied coalescence of haplotypes between nodes, 
%    and we will extend the path's edges to the neighboring tree \ref{fig:extending_diagram}.
%  	In more concrete terms, for a tree $T_k$ in the tree sequence $\T$ 
%    suppose there exists a path which contains a node $3$,
%    with parent and child nodes $4$ and $0$, respectively.
%    If there is an edge between the nodes $4$ and $0$ in trees 
%    $T_{k+1}$ (or $T_{k-1}$),
%    then we wish to extend the edges $4\to 3$ and $3\to 0$ 
%    into tree $T_{k+1}$ and then remove the edge $4 \to 0$ from $T_{k+1}$. 
%    This action reduces the length of $4 \to 0$ on the genome,
%    and in some cases, completely removes the edge. 
%    We now perform this action on all such ancestral paths 
%    over the entire tree sequence.
%    With algorithm \ref{alg:edge} we only extend existing edges
%    \comment{Note possible change pending algorithm change}
%    over a larger interval on the genome,
%    and remove unnecessary edges in the process.

\section{Methods}

\subsection{Notation and terminology}

We use work with the \emph{succinct tree sequence} representation of the ARG (henceforth, ``tree sequence''),
to take advantage of the extensive, stable, and well-documented set of open-source tools
available in \tskit{} \citep{tskit}.
So, our terminology and notation follows \citet{ralph2020efficiently}.
For our purposes here,
a tree sequence $\T = (N, E)$ contains a set of \emph{nodes} $N$ 
which represent ancestral segments of genome,
and \emph{edges} $E$ which represent relationships between nodes over different regions of the genome.
Each node $n \in N$ has a \emph{time} $t_n$,
which is the amount of time in the past that the individual who carried that segment of genome lived.
Each edge $e \in E$ describes inheritance between a parent node $p_e$ and child node $c_e$,
over a segment of genome $[\ell_e, r_e)$.
(The tree sequence includes substantially more information, including genotypes, but we will not use that in this paper.)
Suppose that the unique elements of the set of left and right edge endpoints
are $0 = a_0 < a_1 < \cdots < a_{n} = L$, where $L$ is the length of the genome.
Using this information, one can construct the sequence of 
trees $\left(T_1,...,T_{n}\right)$ that describe how the nodes are related to each other along the genome:
each $T_k$ is a tree whose nodes are in $N$
and that describes relationships on the half-open interval $[a_{k-1}, a_k)$.
Not all nodes appear in each tree,
and we say $n \in T_k$ for a node $n$ if the tree $T_k$ describes at least one parent-child relationship
for node $n$.

\subsection{An algorithm to extend haplotypes}

% Description of algorithm
Given a tree sequence, our goal is to
identify areas of implied inheritance of haplotypes.
Generalizing from \figref{fig:extending_diagram},
we do this by identifying paths of inheritance that are shared across a sequence of marginal trees
but for which some of the intermediate nodes are missing.
Concretely, suppose that 
if in tree $T_k$ there is a chain of inheritance
$p \to u_1 \to \cdots \to u_m \to c$
(where $a \to b$ denotes a parent-child relationship)
and in tree $T_{k+1}$ there is a chain of inheritance
$p \to v_1 \to \cdots \to v_n \to c$,
where $\{u_i\}_{i=1}^m$ and $\{v_j\}_{j=1}^n$ are disjoint.
This situation implies that $c$ inherited from $p$ over the entire interval $[a_{k-1}, a_{k+1})$,
so it seems reasonable to assume that $c$ has inherited from $p$ \emph{along the same path} for that entire interval.
In other words, the intermediate nodes $\{u_i\}$ should also lie on the path from $c$ to $p$ in tree $T_{k+1}$,
and conversely the nodes $\{v_j\}$ should lie on that path in tree $T_k$.
Of course, this does not always make sense --
for instance, if $u_i$ is already represented somewhere else in $T_{k+1}$,
or if $t_{u_i} = t_{v_j}$ for some $i$ and $j$.
for which the intermediate nodes are not in the other tree
So, we restrict our attention to pairs of such paths in adjacent trees
for which
$u_i \notin T_{k+1}$ for all $1 \le i \le m$,
$v_j \notin T_k$ for all $1 \le j \le n$,
and the times of the nodes $\{u_i\}$ and $\{v_j\}$ are unique.
Call a pair of such paths \emph{mergeable}.
So, the goal of our algorithm is to iterate over trees,
identify mergeable pairs of paths,
and then extend the nodes $\{u_i\}$ to $T_{k+1}$.
(We also extend $\{v_j\}$ to $T_k$, but on a backwards pass.)

\begin{figure}[!ht]
\begin{center}
	\includegraphics[width=5in]{edge_extend_method.pdf}
\end{center}
\caption{A visualization of the \textit{extend haplotypes} method. Given two neighboring trees $T_1$ and $T_2$, there exists paths from root node $6$ to sample node $0$. $T_1$ contains the path $6\to 4\to 0$ while $T_2$ has path $6\to 5\to 0$. The intermediate nodes $4$ and $5$ do not appear in $T_2$ respectively $T_1$, and so we consider these two paths \textit{mergeable}. The extend haplotypes method joins these two paths, constructing the merged path $6\to 5\to 4\to 0$ for both $T_1$ and $T_2$. This new path extends the edge $4\to 0$ to $T_2$ as well as constructs a new edge $5\to 4$ in the tree sequence.
    \label{fig:extending_diagram}
}
\end{figure}

\begin{figure}[!ht]
	\begin{center}
		\includegraphics[width=0.4\linewidth, height=1.2in]{EH-Ex2.pdf}
		\includegraphics[width=0.4\linewidth, height=1.2in]{EH-extended-Ex2.pdf}
	\end{center}
	\caption{\comment{DELETE}}
%	\caption{\comment{Change figure to have the same arrow with 'Extend Haplotypes' in inkscape for unity's sake.}The extend haplotypes method between tree with more unary nodes. Given two neighboring trees, there exists paths $4\to 6\to8\to10$ and $5\to 9\to 10$ in $F_O$, and in $F_I$ we have paths $4\to 7\to 11\to 10$ and $5\to 12\to 10$. Both the out-forest and in-forest both contain paths with the same initial and terminal nodes, $4\to 10$ and $5\to 10$ respectively, we merge both paths and output the tree sequence on the right.}
	\label{fig:complicated_extending_diagram}
\end{figure}

A relatively efficient algorithm to do this is described in \algorithmref{alg:extend}, 
and implemented in \tskit{} as \texttt{extend\_haplotypes}.
The algorithm considers each tree transition from $T_k$ to $T_{k+1}$ in turn, updating its internal state
(which includes possibly modifying $T_k$) as it goes.
Suppose we are at the transition from tree $T_k$ to tree $T_{k+1}$,
which is done by first removing a set of edges $O$
and then adding another set of edges $I$.
$O$ defines a sub-forest $F_O$ of $T_k$,
and $I$ defines a sub-forest $F_I$ of $T_{k+1}$.
The key step in the algorithm is to determine whether the pair of paths
that terminate in a given node in two adjacent trees are mergeable,
\algorithmref{alg:mergeable}, which works as follows.
If a pair of paths is mergeable,
then the edges of the two paths must lie in $O$ and $I$, respectively.
Suppose an edge in $O$ has child $c$.
To see if $c$ is the base of a pair of mergeable paths,
the algorithm traverses up from $c$ in both $F_O$ and $F_I$;
terminating if a node in the other tree is found
(i.e., if the node traversed in $F_O$ is in $T_{k+1}$ or if the node traversed in $F_I$ is in $T_k$)
or if a pair of traversed nodes have the same time.
If these two traversals end in the same node $p$, the paths are mergeable.
Iterating over all edges in $O$ will thus find all mergeable pairs of paths.
There is often more than one pair of mergeable paths in a tree transition;
so, the algorithm merges pairs of mergeable paths,
starting with pairs that add the smallest number of new edges,
until no more are found.


\algorithmref{alg:extend} simplifies the algorithm in several ways --
for instance, the bookeeping required to keep track of $T_k$ and $T_{k+1}$ is omitted.
Furthermore, as described the algorithm does one left-to-right pass over the tree sequence;
in practice we do repeated passes in both directions until no changes can be made.
The main step that is omitted is a description of the \texttt{merge} operation,
which performs the actual extending of haplotypes.
This algorithm is essentially the same as \texttt{mergeable} in \algorithmref{alg:mergeable},
except with additional bookkeeping.
Roughly speaking, the algorithm
traverses up from the shared base node $c$,
doing the appropriate operations to insert the nodes along the path found in $T_k$
into the path in $T_{k+1}$.
To do this, some edges that end at $a_k$ will be extended to end at $a_{k+1}$;
some edges that begin at $a_k$ will be postponed to begin at $a_{k+1}$,
and some entirely new edges may be added, see \figref{fig:extending_diagram}.
Furthermore, the trees $T_k$ and $T_{k+1}$ (and corresponding forests $F_O$ and $F_I$)
need to be updated.


\begin{algorithm2e}[!ht]
	\SetStartEndCondition{ }{}{}%
	\SetKwProg{Fn}{def}{\string:}{}
	\SetKwFunction{Range}{range}%%
	\SetKw{KwTo}{in}
	\SetKwFor{For}{for}{\string:}{}%
	\SetKwIF{If}{ElseIf}{Else}{if}{:}{elif}{else:}{}%
	\SetKwFor{While}{while}{:}{fintq}%
	\SetKw{Break}{break}
	\newcommand\forcond{$i$ \KwTo\Range{$n$}}
	\AlgoDontDisplayBlockMarkers\SetAlgoNoEnd\SetAlgoNoLine%
    \caption{
        Given a node $c$, trees $T_O$ and $T_I$,
        and sub-forests $F_O$ and $F_I$
        such that removing $F_O$ and adding $F_I$ turns $T_O$ into $T_I$,
        checks to see if the paths upwards from $c$ in $T_O$ and $T_I$ are mergeable.
        If the paths are mergeable then this returns the number of new edges
        that would be added by extending the path from $T_O$ to $T_I$;
        otherwise, returns $\infty$.
        Let $P_O[n]$ and $P_I[n]$ be the parents of node $n$
        in the set of edges to be removed and added, respectively
        (i.e., in $F_O$ and $F_I$).
    }
	\label{alg:mergeable}
	\SetKwFunction{mergeable}{Mergeable}
	\DontPrintSemicolon
    \Fn{\mergeable($c$, $T_O$, $T_I$)}{
        $p_i = P_I[c]$\;
        $t_i = t[p_i]$\;
        $p_o = P_O[c]$\;
        $t_o = t[p_o]$\;
        $n_e = n = 0$\;
        \While{\tn{True}}{
            $y_i = (p_i \neq NULL)
                \text{ and } (p_i \notin T_O)
                \text{ and } (t_i < t_o)$ \;
            $y_o = (p_o \neq NULL)
                \text{ and } (p_o \notin T_I)
                \text{ and } (t_o < t_i)$ \;
            \If{not ($y_i$ or $y_o$)}{ \Break\; }
            \eIf{$y_i$}{
                \If{$P_I[c] \neq p_i$ and $P_O[c] \neq p_i$}{
                    $n_e += 1$\;
                }
                $c = p_i$\;
                $p_i = P_I[p_i]$\;
                $t_i = (p_i = NULL) ? \infty : t[p_i]$\;
            }{
                \If{$P_I[c] \neq p_o$ and $P_O[c] \neq p_o$}{
                    $n_e += 1$\;
                }
                $c = p_o$\;
                $p_o = P_O[p_o]$\;
                $t_o = (p_o = NULL) ? \infty : t[p_o]$\;
                $n += 1$\;
            }
        }
        \If{$n = 0$ or $p_i \neq p_o$ or $p_i = NULL$}{
            $n_e = \infty$\;
        }
        \KwRet{$n_e$}\;
    }
\end{algorithm2e}

\begin{algorithm2e}[!ht]
	\SetStartEndCondition{ }{}{}%
	\SetKwProg{Fn}{def}{\string:}{}
	\SetKwFunction{Range}{range}%%
	\SetKw{KwTo}{in}
	\SetKwFor{For}{for}{\string:}{}%
	\SetKwIF{If}{ElseIf}{Else}{if}{:}{elif}{else:}{}%
	\SetKwFor{While}{while}{:}{fintq}%
	\SetKw{Break}{break}
	\newcommand\forcond{$i$ \KwTo\Range{$n$}}
	\AlgoDontDisplayBlockMarkers\SetAlgoNoEnd\SetAlgoNoLine%
    \caption{
        Extend haplotypes.
        \comment{TODO: include this in the previous algorithm?}
    }
	\label{alg:extend}
	\SetKwFunction{mergeable}{Mergeable}
	\SetKwFunction{merge}{Merge}
	\SetKwFunction{extend}{ExtendHaplotypes}
	\DontPrintSemicolon
    \Fn{\extend($\T$)}{
        \For{$k$ in $1 \ldots N$}{
            $M = 0$\;
            $M' = \infty$\;
            \While{$M < \infty$}{
                \For{$e \in O_k$}{
                    $m$ = \mergeable($c_e$, $T_k$, $T_{k+1}$)\;
                    \eIf{$m < M$}{
                        \merge($c_e$, $T_k$, $T_{k+1}$)\;
                    }{
                        $M' = \min(m, M)$\;
                    }
                }
                $M = M'$\;
                $M' = \infty$\;
            }
        }
    }
\end{algorithm2e}

Since the algorithm needs to take multiple passes over the tree sequence
in each direction,
an important practical quesiton for this algorithm is:
how passes do we need to do?
The algorithm is monotone (spans of ancestral nodes only increase),
so it is guaranteed to require only a finite number of passes,
but it is also not hard to construct pathalogical cases that require an arbitrary number of passes.
\figref{fig:num_passes} shows empirical results from simulated tree sequences,
which suggest that only at most five iterations are needed before the algorithm terminates. Indeed, for even larger sequences \ref{tab:edge-counts} shows that 99\% of all changes to an ARG occur after the first iteration with the algorithm completing after four iterations. \comment{ XXX Do we want to add more here? XXX}

\begin{figure}[!ht]
    \caption{
        Number of edges in the tree sequence (vertical axis)
        after each pass of the algorithm (number of passes on the horizontal axis),
        for tree sequences with different numbers of samples (different lines).
        \comment{TODO}
        \label{fig:num_passes}
    }
\end{figure}

%% Find counter example to global minimum.

\subsection{Dissimilarity Function}
% * How to measure agreement that includes haplotypes
% * Definition and Algorithm
% * Supp fig: runtime ~ # trees, samples
% * fig: how add edges reduces discrepancy (RESULTS)
%       - compare to tsinfer
% * Show: how add edges reduces discrepancy (RESULTS)

\comment{Rename Dissimilarity and Similarity}

If we begin with a tree sequence containing unary nodes,
it is straightforward to remove the portions of each node's span on which it is unary,
apply \algorithmref{alg:extend},
and quantify how much node span was correctly or incorrectly added.
However, we are also interested in whether \algorithmref{alg:extend}
improves \emph{inferred} tree sequences.
Since we are not aware of any current methods for measuring (dis)agreement between tree sequences
that take into account haplotype identity,
we define a measure of \emph{dissimilarity} to quantify this.
The method is implemented in the \texttt{tsdate} package \citep{wohns2022unified}
as \comment{XXX}.

It is helpful to first describe what we compute in the simple case.
\figref{fig:node-spans}A shows the spans for each node in three tree sequences:
for each node, the top point is the total span in a ``true'' tree sequence
that was simulated with \msprime \citep{kelleher2016efficient,baumdicker2021efficient}
in a way that included spans over which nodes are unary in the output
(by setting \texttt{coalescing\_segments\_only} to False).
The bottom point is the span of the node after \emph{simplifying} the tree sequence
\citep{kelleher2018efficient},
which removes all unary nodes from all trees.
\comment{Usually (?)} between the two points
is the span of the node after applying \algorithmref{alg:extend}
to the simplified tree sequence.
So, the difference between the middle and bottom points is the amount by which
the span of that node has been extended.
\figref{fig:node-spans}B \comment{TODO} shows how much of this span is incorrect:
for each node, it gives the percent of the span after running \algorithmref{alg:extend}
that is incorrect (i.e., not present in the original tree sequence).
The values in these plots (perhaps summed over nodes)
therefore quantify how much the ancestral haplotypes represented by each node
were correctly, and incorrectly, extended.
They also tell us how much of the relationships in the original tree sequence
are represented in the result.

Now suppose that instead of comparing two tree sequences with the same set of nodes,
we wish to compare two tree sequences for which we know the sample nodes are the same
but are not given an identification between nodes otherwise
(as for instance with a true, simulated tree sequence and one inferred from its genotypes).
\comment{should have introduced ``samples'' before this}
Call the two tree sequence $T_1$ and $T_2$, which should have the same genome length
and the same set of sample nodes.
We would like to measure (a) how much of $T_1$ is found in $T_2$;
(b) how much of $T_1$ is \emph{not} found in $T_2$; and
(c) how much of $T_2$ is not found in $T_1$.
(Think of these three quantities as the size of the intersection
and two differences between the tree sequences,
thought of vaguely as sets.)
Roughly speaking, we first identify matching nodes
as those whose sets of descendant samples agree for the largest span along the genome,
and then compute for how much of their spans do their descendant samples agree (or not).

Concretely, suppose that the two tree sequences have the same set of breakpoints
between trees,
so that $T_1^{(1)}, \ldots, T_N^{(1)}$ are the trees in $\T_1$
and $T_1^{(2)}, \ldots, T_N^{(2)}$ are the trees in $\T_2$.
\comment{Should we include an addendum that we can do this for tree sequences with different break points its just a little more tedious?}
For a node $n$ and tree $T$
let $S(T, n)$ denote the set of samples that inherit from $n$ in $T$,
and for a pair of nodes $n_1$ and $n_2$ with $n_1$ in $\T_1$ and $n_2$ in $\T_2$,
define
\begin{align*}
    m(n_1, n_2)
    =
    \sum_{k=1}^N (a_k - a_{k-1}) \ind_{S(T^{(1)}_k(n_1) = S(T^{(2)}_k(n_2)} ,
\end{align*}
which is the total span over which the samples below $n_1$ in $\T_1$
matches the samples below $n_2$ in $\T_2$.
Also let
\begin{align*}
    s(\T, n) = \sum_{k=1}^N (a_k - a_{k-1}) \ind_{n \in T_k} ,
\end{align*}
the total span that node $n$ is present in the marginal trees.
The \emph{similarity} between $\T_1$ and $\T_2$ is then defined to be
\begin{align*}
    \similarity(\T_1, \T_2)
    =
    \max_{\beta:N_1 \to N_2} \sum_{n \in N_1} m(n, \beta(n)) ,
\end{align*}
where the maximum is over all mappings of nodes in $\T_1$ to nodes in $\T_2$.
(Note that multiple nodes in $\T_1$ may be mapped to the same node in $\T_2$,
and that there may be no nodes in $\T_1$ that are mapped to some nodes in $\T_2$.)
Since the maximum is independent over nodes, we may define for each node $n_1 \in \T_1$
it's \emph{best matching node} in $\T_2$ as
\begin{align*}
    \alpha(n_1) = \argmax_{n_2 \in N_2} \frac{1}{1+|t_{n_1}-t_{n_2}|}\max_{n_2\in N_2} m(n_1, n_2) ,
\end{align*}
so that
\begin{align*}
    \similarity(\T_1, \T_2)
    =
    \sum_{n \in N_1} m(n, \alpha(n)) .
\end{align*}
If the best-matching node is unique, we define $\alpha(n_1)$ to be the node in $T_2$
out of those maximizing $m(n_1, n_2)$ that minimizes $|t^{(1)}_{n_1} - t^{(2)}_{n_2}|$
(and if \emph{this} is not unique, we pick an arbitrary one) --
however, this potential ambiguity does not affect the definition of $\similarity(\T_1, \T_2)$.
We then define the \emph{dissimilarity} of $\T_1$ from $\T_2$ by
\begin{align*}
    \dis(\T_1, \T_2)
    =
    \frac{\sum_{n \in N_1} (s(\T_1, n) - m(n, \alpha(n)))}{\sum_{n\in N_1} s(\T_1,n)} ,
\end{align*}
which is the proportion of total span of all nodes in $\T_1$
for which their descendant samples do \emph{not} match those of their best match in $\T_2$.

Other authors \citep[e.g.,]{kelleher2019inferring} have used
an average Robinson-Foulds distance \citep{robinson1981comparison}
as a measure of disagreement between tree sequences.
This could be computed in a very similar way:
instead of $m(n, \alpha(n))$ define
\begin{align*}
    m'(n, \T_2) = \sum_{k=1}^N (a_k - a_{k-1}) \ind_{\exists n_2: s(T^{(2)}_k, n_2) = s(T^{(1)}_k, n)} ,
\end{align*}
the total span over which there is \emph{some} node in $\T_2$ whose set of descendant samples
matches $s(T_1,n)$.
Then the average Robinson-Foulds distance (averaged over locations in the genome)
is
\begin{align*}
    \frac{1}{L} \left( \sum_{n_1 \in N_1} m'(n_1, \T_2)  + \sum_{n_2 \in N_2} m'(n_2, \T_1) \right).
\end{align*}
\comment{Check this!}\comment{Not true. I believe you can have the problem again of two nodes in TS1 match with node in TS2}
In other words, we require a node in $\T_1$ to match the \emph{same} node in $\T_2$
across all trees, but average Robinson-Foulds distance allows a different node to match
on each tree. \comment{I don't think this is true nor do I understand how $m'$ is truely different than $m$. It seems like $m'$ is just the extension of $m$ to the level of tree sequences.}
The other differences are that \emph{average} Robinson-Foulds distance
normalizes by sequence length, and is symmetrized.
Robinson-Foulds distance between two trees
was defined by \citet{robinson1981comparison}
to the minimum number of edge contraction/expansion operations needed to move
from one tree to the other
(which they then show is equal to the number of edges that induce different splits on the labels).
It would be interesting to define a similar metric on tree sequences,
perhaps using the Subgraph-Prune-and-Regraft moves used by Singer \citet{deng2024robust}.

The dissimilarity $\dis(\T_1, \T_2)$ measures disagreement between \emph{topologies},
but not times.
If the tree sequence is dated, we can naturally use the ``best match'' $\alpha$
to also compare times,
for instance by returning the weighted root-mean-squared error on inferred times as
\begin{align*}
    \text{wRMSE}_t(\T_1, \T_2)
    = \sqrt{\frac{
        \sum_{n \in N_1} s(\T_1,n) \left(t^{(1)}_n - t^{(2)}_{\alpha(n)} \right)^2 
    }{
        \sum_{n \in N_1} s(\T_1,n)
    } } .
\end{align*}
The mean is computed weighting by node span, so that a dating error
is more serious for a node with a longer span.
\comment{TODO: change the definition?
In practice, time estimation errors seem to be closer to homoskedastic on a log scale,
so this would probably be more informative if errors are computed on the log sale.} 

We compute the dissimilarity of two tree sequences in \figref{fig:conceptual_discrepancy}.


%%%%%%%%%%%%
%\comment{PREVIOUS VERSION: retrieve bits from below?}
%
%Inspired by Robinson-Foulds we define a function, called a \textit{discrepancy function} (see \algorithmref{alg:disc}), on a pair of tree sequences $\T_1$, $\T_2$ of equal length $L$.
%Let $N_{T_1}$ and $N_{T_2}$ be the set of nodes on $\T_1$ respectively $\T_2$.
%For a pair of nodes $(i,j)\in N_{T_1}\times N_{T_2}$, we define their \textit{discrepancy} as a difference in their total spans over the genome.
%Each node $n\in\T$ has a given position along the genome and time, 
%so we can write each node as a tuple $n = (t_n, L_n)$ with position $L_n\subset \left[0,L\right)$ and time $t_n\in \R^{\geq 0}$.
%Computing the discrepancy between a random pair of nodes is not helpful, 
%so we must first identify which pairs of nodes would be most identical to one another or a `best match'.
%These `best matching' nodes should be close in terms of time and have equal descendant sample sets,
%ie. $s(i) = s(j)$ where $s$ is the function to compute the descendant sample set of $n_1$.
%
%To find a best match for each node $i\in N_{T_1}$ \comment{(Should I do this by mentioning clades?)}
%we compute the \textit{shared span} between node $i\in N_{T_1}$ and every node in $N_{T_2}$.
%Then, the \textit{shared span} between two tree sequences, denoted $ss(\T_1,\T_2)$, is a $|N_{T_1}|\times |N_{T_2}|$ matrix $A$
%where each entry $a_{ij}$ represents the shared span between a pair of nodes $(i,j)\in N_{T_1}\times N_{T_2}$.
%If a pair $(i,j)$ has equal descendant sample sets, $s(i) = s(j)$
%then $a_{ij} = |L_i \cap L_j|$.
%If the pair does not have an equal descendant sample set then we set $a_{ij}=0$.
%Matrix $A$ determines the \textit{best match} for every node $i\in N_{T_1}$
%via looking at the maximum in row $i$, $\alpha_i = \max_{j\in N_{T_2}} a_{ij}$.
%If this maximum is not unique, we use time difference to determine the best match pair.
%We then define the \textit{discrepancy} between $\T_1$ and $\T_2$ as 
%one minus the proportion of sum of the shared spans divided by the total node span of $\T_1$.
%
%We note that the discrepancy function is a metric for detecting non-similarity between two tree sequences. However, we note that this function is not a metric in the mathematical sense, as it is not symmetric, nor is it reflexive. For example, given a tree sequence $\T$ and its simplification $\mathbb{S}$ and $\T\neq\mathbb{S}$ we have $\operatorname{discrepancy}(\mathbb{S}, \T)=0$. Additionally, given \figref{fig:conceptual_discrepancy}, $\operatorname{discrepancy}(T1, T2) \neq \operatorname{discrepancy}(T2, T1)$ \comment{actually compute this. We may just do it in this section instead of the appendix?}
% 
%\comment{Do we want a complete walkthrough of Figure 3? Could be useful in an appendix} 

\begin{figure}[!ht]
	\begin{center}
\includegraphics[height=1.5in, width=3in]{discrepancy_func_method_t1.pdf}
\includegraphics[height=1.5in, width=3in]{discrepancy_function_method_t2.pdf}
    \caption{
        For two tree sequences $T1$ and $T2$ the \emph{dissimilarity function}, $\dis(T1,T2)$, matches nodes in $T1$ to nodes in $T2$
        based on identical sample sets.
        In this example, node $8$ has no match in $T2$ as there are no nodes in $T2$ with sample set $\left\{1,2,3\right\}$.
        Node $4$ has no match on $[4,5)$ and matches with node $9$ on $[5,6)$. On the rest of the genome, all of nodes match with their identical counterpart.
        This makes the dissimilarity $\dis(T1,T2)=\frac{3}{46}$.
        \label{fig:conceptual_discrepancy}
    }
	\end{center}
\end{figure}

%\comment{Delete Discrepancy Algorithm!!}
% 
% \begin{algorithm2e}[!ht]
% \SetStartEndCondition{ }{}{}%
% \SetKwProg{Fn}{def}{\string:}{}
% \SetKwFunction{Range}{range}%%
% \SetKw{KwTo}{in}
% \SetKwFor{For}{for}{\string:}{}%
% \SetKwIF{If}{ElseIf}{Else}{if}{:}{elif}{else:}{}%
% \SetKwFor{While}{while}{:}{fintq}%
% \SetKw{Break}{break}
% \newcommand\forcond{$i$ \KwTo\Range{$n$}}
% \SetKwComment{Comment}{}
% \AlgoDontDisplayBlockMarkers\SetAlgoNoEnd\SetAlgoNoLine%
% \DontPrintSemicolon\LinesNotNumbered
% 
% \caption{Discrepancy Function}\label{alg:disc}
% \input{$(T_1,T_2)$}
% \output{tree discrepancy, root-mean-square error}
% 
% \Fn{Shared Spans($T_1,T_2$)}{
% \For{pairs $(i,j)\in N_{T_1}\times N_{T_2}$}{
% 	$i = (t_i, L_i)$ and $j = (t_j, L_j)$ where $L_i, L_j\subset \left[0,L\right).\quad$ \Comment{Each node is a tuple (time, genome location).}
% 	\If{$(i,j)$ has equal sample sets, $s(i)=s(j)$}{
% 		Define $a_{ij}=|L_i\cap L_j|$.
% 	}
% 	\Else{Define $a_{ij}=0$.}
% Define matrix $A=\left[a_{ij}\right]\in M_{N_{T_1}\times N_{T_2}}(\R)$.\;
% }
% \KwRet{$A$}
% }
%\BlankLine
%\Fn{Discrepancy ($T_1,T_2$)}{
%\For{each node $i\in N_{T_1}$}{
%	Find nodes in $N_{T_2}$ which have the highest matching span.\;
%	$\operatorname{matches}_i = \argmax_{k\in N_{T_2}} a_{ik}.$\;
%	Let $j = \argmax_{k\in \operatorname{matches}_i}\frac{1}{1+|t_i-t_k|}$.\;
%	Define $\alpha_i = a_{ij}$.\;
%	\BlankLine
%}
%$$tree\ discrepancy = 1 - \frac{\sum_{i\in N_{T_1}} \alpha_i}{\operatorname{tr}\left(Shared Spans(T_1, T_1)\right)}$$\;
%\BlankLine\BlankLine
%$$rmse = \sqrt{\frac{\sum_{i\in N_{T_1}}|t_i - t_j|\alpha_i}{\operatorname{tr}\left(Shared Spans(T_1,T_1)\right)}}$$\;
%\BlankLine
%$$true\ proportion = \frac{\sum_{i\in N_{T_1}} \alpha_i}{\operatorname(tr)\left( Shared Spans(T_2, T_2)\right)}$$\;
%\BlankLine\BlankLine
%\KwRet{tree discrepancy, rmse, true proportion}
%}
%\end{algorithm2e}


\subsection{Simulations}

To do this, we simulate ARGs containing full haplotypes using \msprime's 
option \texttt{coalescing\_segments\_only} set to False.
Although \msprime simulates many events that do not create a coalescence in some marginal tree,
it only outputs information for nodes which contain a coalescence
(i.e., are the MRCA of some pair of samples at some point on the genome).
Furthermore, by default it only outputs those segments of the genome
on which there is a coalescence.
Said another way, by default all ancestral nodes in the ARG
output by \msprime are the MRCA of some pair of samples at every point in the genome
on which they are represented.
However, here we are interested in those segments of genome
on which the nodes are \emph{not} coalescent;
i.e., where they are unary in the marginal trees.
More concretely, we hope to recover those portions of ancestral haplotypes
on which the nodes are unary, but adjacent to a region of the genome where the node is not unary.
For instance, if a lineage carrying an ancestral segment of genome that spans $[a, c)$
coalesces with another spanning $[b, d)$, with $a < b < c < d$,
then the resulting node is only coalescent on $[b, c)$ but we hope using this algorithm
to extend the node's span to $[a, b)$ and $[c, d)$
(on which the node is unary).
However, following this example, the first lineage might carry a segment $[x, y)$
that is disjoint from $[a, d)$.
We call these segments ``isolated non-coalescent segments'';
they have also been called ``trapped unary spans'' \citep[by][]{XXX}.
Such segments will not be recovered by our algorithm,
and it seems likely that most such segments are unrecoverable by any method.
So, when evaluating what proportion of the true ARG is represented in an inferred ARG
we omit these isolated non-coalescent segments.
To give an idea of what proportion of the full spans of ancestral nodes
these isolated non-coalescent segments represent,
a simulation of 1000 samples
with genome length $5\times 10^7$, recombination rate $10^{-8}$, and population size $10^4$
has about half the total span of all nodes in isolated, non-coalescent segments.
For more discussion of these segments, see \citet{baumdicker2021efficient}.


\section{Results}

% Outline:
% 1. benchmarking: edge reduction and runtime
% 2. correctness:

%% TO DO:
%% 1. Discuss trapped unary spans more
%% 2. Discuss the comparison between tsinfer and extend haplotypes
%% 3. Add more figures 
%%	- (Edge counts between tsinfer and extend haplotypes)
%%	- Average Edge counts per iterations
%% 4. Discuss figures about total edge span added in both recombination and gene conversion events
%% 5. Discuss the figures on edge reduction (include #3 part 1.)

%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Tree sequence compression and computation}

\comment{TODO: put in benchmarking figures}

In the simple example in \figref{fig:conceptual},
extending haplotypes replaces three edges
($0 \to 3$ and $3 \to 4$ on the left tree, and $0 \to 4$ on the right tree)
by two edges ($0 \to 3$ and $3 \to 4$ on both trees).
If all edge endpoints were unique, then we'd expect \emph{every} edge to be extendable
on one of its ends
(except those pendant to the root and some of those adjacent to chromosome ends),
leading to a reduction in number of edges by 1/3.
Experiments with an earlier version of the algorithm showed that
if we only extend haplotypes on ``paths of length 1'' like this, 
then this is achieved for long sequences.
It is possible for \algorithmref{alg:extend} to add edges, as in \figref{fig:extending_diagram},
but we still expect the number of edges to decrease by more than 1/3.
Indeed,
\figref{fig:num_edges} shows that \algorithmref{alg:extend} nearly cuts the number of edges
in half, as long as the sequence is long enough.

This reduction in edges can also lead to a reduction in computation time.
Indeed, \figref{fig:num_edges} shows that computation time is reduced by 10--20\%
for a typical statistic (here, Tajima's $D$),
computed in an efficient iterative manner along the genome as implemented in \tskit.
This is actually somewhat surprising:
as described in \citet{ralph2020efficiently},
each edge added or removed requires an update
to the state of the parent node \emph{and every node above it in the tree}.
So, even if an edge extends for a long segment of genome,
something has to happen to it every time the subtree below it changes,
which is not affected by extending haplotypes.

%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Accuracy with true trees}

Our next task is to confirm that the haplotypes extended by \algorithmref{alg:extend}
are indeed correct -- i.e., that in addition to compression, we are also gaining information.
To do this, 
we simulate ARGs containing full haplotypes using \msprime{},
apply the simplification algorithm to reduce these so that there are no unary nodes
(i.e., any node present in a marginal tree is a coalescent node or a sample),
and then apply \algorithmref{alg:extend} to the result
(see Methods for more detail).
The method can potentially extend the spans of each node
(spans on which the node will be unary);
and we can quantify how much of these extended spans were in the original ARG
(and thus correctly extended).

\comment{TODO: figure out if we can remove this from figures. If so, move this to Methods.}
Some stuff can't be inferred since it's "isolated unary";
for instance with 1,000 samples, 5e7 that's about half the ARG.
Etcetera.

%$msprime.sim_ancestry(1000, sequence_length=5e7, recombination_rate=1e-8, population_size=1e4, coalescing_segments_only=False, random_seed=1)$
%From the above output we see that ratio of unary span bordering coalescing between 
%- ExtendPaths/Truth = 0.4917
%- ExtendEdges/Truth = 0.27828
%
%The trapped unary span of our ground truth is 49\% of the TS.
%
%Total unary span bordering coalescing: 255151996720.0 (51.0\%)
%Total trapped unary span: 245038231157.0 (49.0\%)
%Total coalescing span: 99950000000.0
%Total unary span bordering coalescing: 125466159245.0 (100.0\%)
%Total trapped unary span: 0.0 (0.0\%)
%Total coalescing span: 99950000000.0

As seen in \figref{fig:node-spans},
Look, we add lots of stuff
and most most of it is right;
this applies to both recent and ancient nodes;
we're typically extending the span of a node by like maybe 50\%. 

\begin{figure}[bht]
	\includegraphics[width=0.9\linewidth]{newplots_wo_ee/node_spans_wo_trapped_unary_regions_CDF.pdf}
	\caption{
        Node spans of simulated tree sequence (blue), simplified tree sequence (green), and extended tree sequence (red).
        \comment{TODO: nodes should be in the same order in all three lines,
        using the ordering from the true tree sequence.}
        \comment{TODO: somehow communicate per-node amount/proportion of correctly and incorrectly added span}
    }
	\label{fig:node-spans}
\end{figure}

\comment{merge this in}
The first thing we see is that coalescent nodes are unary
over a substantial portion of their spans:
since the \texttt{simplify} operations removes these unary spans,
the ``simplified'' line on the right of Figure~\ref{fig:discrepancy} shows
the proportion of nodes' spans on which they are not unary.
For instance, on an ARG of 10 samples on a sequence of length $5 \times 10^7$,
only about 15\% of the total spans are retained after simplification;
this rises to around 50\% for 1,000 samples (top right plot)

We can also use measures of dissimiliarity and similarity to quantify summaries across nodes:
these are shown in \figref{} (purple lines only)
Points:
proportion left after smiplify varies a LOT: from 15\% to 95\%.
    (goes up with L: with longer sequence length, greater opportunity for distant chunks to be on the same lineage)
extending adds hardly any wrong stuff (left plots); and adds a substantial chunk: with large samples, adds like half of the missing stuff

It's also interesting to  note that inference
(see \figref{fig:inferred_edge_counts})
(a) increases number of edges;
(b) but inferred-simplifies have even more suggesting unary stuff is parsimonious;
(c) but then extending reduces to below the original.


\begin{figure}
	\begin{center}
		% \includegraphics[width=0.8\linewidth]{newplots_wo_ee/discrepancy_over_sample_5e7_new.pdf}
		% \includegraphics[width=0.8\linewidth]{newplots_wo_ee/discrepancy_over_seqlen_1000s_new_5e7.pdf}
        \includegraphics[width=\textwidth]{dissimilarity.pdf}
	\end{center}
    \caption{
        Accuracy and sensitivity of extended haplotypes
        across a range of sample sizes, on a sequence of length $5\times10^7$ (top)
        and sequence lengths, with 1,000 \comment{diploid?} samples (bottom).
        For each, a simulated ARG containing unary haplotype spans
        was (i) \emph{simplified}, removing the unary spans,
        and (ii) \emph{inferred}, using \tsinfer{} on genotypes;
        then each of these had its haplotypes \emph{extended}.
        The inferred, then simplified, ARG is also shown.
        \textbf{Left:} Discrepancy to the true ARG,
        as proportion of haplotypes that are not represented in the true ARG
        (equation~\eqref{eq:discrepancy}).
        \textbf{Right:} Agreement to the true ARG,
        as proportion of the true ARG that is represented.
        The largest number of trees in the bottom row corresponds
        to the sequence length in the top row;
        see text for more details.
        \comment{TODO: make "inferred simplified" green (dotted) not red}
        \comment{TODO: label "inferred extended" "inferred simplfieid extended"??}
        \comment{TODO: also add a "inferred extended" line}
    }
    \label{fig:discrepancy}
\end{figure}

\begin{figure}
	\includegraphics[width=0.9\linewidth]{newplots_wo_ee/edge_counts_5e7.pdf}
    \caption{
        number of edges, 5e7, 1,000 samples
        \label{fig:inferred_edge_counts}
    }
\end{figure}


%%%%%%%%%%%%%%%%%%
\subsection{Inferred ARGs}

So far, we have demonstrated that there is potentially ample information
in the coalescent-only trees to extend haplotypes.
Does this work with \emph{inferred} ARGs?
Indeed, most ARG inference methods provide inferred ARGS already containing unary nodes;
to what degree are they taking advantage of this information already?
Here, we study the behavior of \tsinfer{},
leaving a comparison of different ARG inference methods for future work.
To study this, we simulated ARGs containing unary-spanning haplotypes (as above),
then performed various operations to them,
reporting proportions of correct and incorrect haplotype spans in Figure~\ref{fig:discrepancy}.

Main points: in \figref{fig:discrepancy}
(green line) tsinfer gets a lot right (above 60\% with 1000 samples; bottom-right plot)
    and does a lot better with more samples;
    also, gets 10\%--25\% wrong (left panels)
    with longer sequence, larger proportion is wrong (bottom-left panel)
(red dotted)
    simplifying removes a lot of the wrong stuff
    but also a lot of the right stuff
(red solid)
    similarly extending the simplified one adds a bunch of right and also wrong stuff
    



\begin{figure}[bht]
	\includegraphics[width=0.9\linewidth]{newplots_wo_ee/better_unary_spans_ep_log.pdf}
	\caption{Correct Unary Span for Extend Haplotypes (log)}
	\label{fig:correct-unary-span-log}
\end{figure}

\begin{figure}
%	\includegraphics[width=0.9\linewidth]{newplots_wo_ee/avg_edge_count_over_iters_5e7_1000s.pdf}
	\caption{The average number of edges for an extended tree sequence per iteration of the extend haplotypes algorithm.}
	\label{fig:edges-per-iteration}
\end{figure}

% (AVA)
% * reduction in edges ~ sequence length
% * speed increase ~ sequence length
% * proprotion of added edges that are true ~ sequeence length

%\begin{figure}
%	\includegraphics[width=0.9\textwidth]{newplots_wo_ee/simp_vs_ext_tajimasD_runtime_numtrees.pdf}
%    \caption{
%        Two-part figure, showing reduction in number of edges (left) and increase in speed of stats comptuation (right)
%        as a function of number of trees (modulated by sequence length),
%        on reasonably big simulated sequences.
%        For "speed": plot ratio of runtime before/after extending.
%        \label{fig:speed_and_edges}
%    }
%\end{figure}

%Simple experiment:
%(1) simulate, simplify, and extend;
%(2) let $x$ be total matching span of simplified tree (here equal to the total span); $y$ total matching span of extended tree in truth and $z$ total not-matching span;
%then $z$ is "total wrongly added stuff" and $y-x$ is "total rightly added stuff".
%
%With tsinfer: (1) simulate and tsinfer; (2) do the above either with or without simplifying the tsinfer'ed trees.
%(but also take into account that there's wrong stuff in tsinfer'ed tree: look at whether it reduces discrepancy!)

\begin{figure}
	\includegraphics[width=0.9\linewidth]{newplots_wo_ee/sampling_dist_geneconversion.pdf}
	\caption{
        Accuracy of \algorithmref{alg:extend}
        on simulated ARGs with sample size $10^2$, length $10^7$, gene conversion rate $10^{-8}$ and gene tract length = $10^3$.
        The same quantities for simulated ARGs without gene conversion
        are shown in Supplementary \figref{fig:accuracy_on_truth_no_gc}.
    \label{fig:accuracy_on_truth}
}
\end{figure}

\begin{figure}
	\includegraphics[width=0.9\linewidth]{newplots_wo_ee/sampling_dist_recomb.pdf}
	\caption{Accuracy of \algorithmref{alg:extend}
        as in \figref{fig:accuracy_on_truth} except that simulations were done
        without gene conversion. \comment{Add to supplement.}
        \label{fig:accuracy_on_truth_no_gc}
    }
\end{figure}

\subsection{Data}
% * 1. Simulate data
% * 2. Run tsinfer
% * 3. Compare d(x,truth) for x in tsinfer, tsinfer+add edge, tsinfer+add edge + simplify, tsinfer+simplify

% * How much unary edges?
% * How much can we add?

% * apply to real data:
%     - % fewer edges
%     - % fewer distinct ancestors (ancestral paths?) of sample at some time

\section{Discussion}

TODO

In this paper, we have taken a ``historical'' view of the ARG --
i.e., that each aspect of an inferred ARG is intended to represent
a portion of some particular historical genome
(for instance, the MRCA of some set of sampled genomes).
Furthermore, \figref{fig:conceptual}A\&B implicitly takes the position
that relationships \emph{not} depicted in the ARG are implied to not exist.
This is slighly disingenuous -- an alternative and more accurate interpetation
of the ARG of \figref{fig:conceptual}A\&B would be that we do not know
how node 2 inherited from node 4 on the right-hand interval,
rather than saying that it specifically did not pass through node 3.
The ``simplification'' algorithm of \citet{kelleher2018efficient},
or the Hudson algorithm for coalescent simulation
as implemented in msprime \citep{kelleher2016efficient},
each specifically discard information about any such ``non-coalescent'' nodes;
so the correct interpretation of these ARGs is a lack of knowledge.
In this paper, we have shown that this information can be largely replaced.


\paragraph{Metrics on ARGs}
\comment{collecting random notes here; TODO is tie them together}
The dissimilarity $\dis(\T_1,\T_2)$ is clearly not a metric in the mathematical sense
(i.e., symmetric, nonzero distance between distinct points, and satisfying the triangle inequality).
This is by design: in practice it is not possible to infer all aspects
of the true ancestry of a set of samples (i.e., all their genetic ancestors who ever lived),
and so we wanted to quantify
``How much of the true relationships does this ARG represent?''
However, the symmetrized version
$d(\T_1,\T_2) = \dis(\T_1,\T_2) + \dis(\T_2, \T_1)$ is a metric.
To see this, first suppose that we have a bijection between the nodes of $\T_1$ and $\T_2$,
and view each ARG as a subset of the space $[0,L) \times N \times N$,
where $N$ is the shared set of nodes.
Then, dissimilarity is the Lesbegue measure of the relative difference of the two sets:
$|\T_1 \setminus \T_2|$,
and so the symmetrized version is the measure of the symmetric difference,
which is well-known to be a metric.
If the two ARGs have the same number of nodes,
then we take the minimum over the all bijections between their nodes,
and minima over a finite number of metrics is also a metric.
Finally, if they have a different number of nodes,
then \comment{???}.

The Robinson-Foulds distance \citep{robinson1981comparison}
essentially counts the number of differing branches between two trees;
the averaged Robinson-Foulds distance \citep{kelleher2019inferring} % TODO: first usage?
combines this distance across marginal trees, weighted by span along the genome.
The method we present here for measuring dissimilarity between topologies of ARGs
is a straightforward generalization
that takes into account span along the genome of inferred ancestral haplotypes
(and separates the metric into two pieces as discussed in the previous paragraph).
However, the Robinson-Foulds metric has many undesireable properties --
for instance, moving a single tip can result in a tree with maximum distance to the original --
and there is a substantial literature giving generalizations
\citep[reviewed by][]{llabres2021generalized}.
Many of these generalizations \citep[e.g.,][]{bocker2013generalized}
relax the requirement that the match between subtended sample sets be exact,
and weight matches in some way by the size of the dissimilarity.
We considered such definitions as well, but kept to the simple case
for computational tractability --
the generalization of \citet{bocker2013generalized} is NP-hard to compute, even for a single tree.
In the ARG literature, \citet{zhang2023biobankscale}
defines a metric (called ``ARG total variation distance'') that includes branch lengths,
in a way similar to \citet{robinson1979comparison} and \citet{kuhner1994simulation};
however, it is still applied to ARGs as an average over marginal trees,
without enforcement of identity across haplotypes;
it would be useful to extend our dissimilarity to include branch lengths.

\paragraph{Inference methods}
\comment{Possibly an overview of what the different inference methods do with unary spans?}

\bibliography{references}

\appendix

%\begin{figure}
%    \caption{
%        Supplementary figure: runtime of discrepancy function as a function of number of trees
%        (which we modulate by changing sequence length).
%        \label{fig:speed_discrepancy}
%    }
%\end{figure}

\begin{table}[hbt]
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
	\hline
	Initial & Iteration 1 & Iteration 2 & Iteration 3 & Iteration 4 \\
	\hline
	\hline
	113463	&	76301	&	76059	&	76057	&	76057 \\
	\hline
	113266 & 76084	&	75835	&	75833	&	75833 \\
	\hline
	114489 & 76703 & 76436 & 76434 & 76434 \\
	\hline
	114086	& 76550	& 76294	& 76291	& 76291\\
	\hline
\end{tabular}
\caption{Number of edges for each iteration of \textit{extend haplotypes} applied to 
simulated tree sequences with sample size $10^4$ and length $5\times 10^7$. 
Each of the simulations terminated by the fourth iteration, however 99\% of the edges
are removed within the first iteration.}
\label{tab:edge-counts}
\end{center}
\end{table}

%\begin{algorithm2e}[!ht]
%	\SetStartEndCondition{ }{}{}%
%	\SetKwProg{Fn}{def}{\string:}{}
%	\SetKwFunction{Range}{range}%%
%	\SetKw{KwTo}{in}
%	\SetKwFor{For}{for}{\string:}{}%
%	\SetKwIF{If}{ElseIf}{Else}{if}{:}{elif}{else:}{}%
%	\SetKwFor{While}{while}{:}{fintq}%
%	\SetKw{Break}{break}
%	\newcommand\forcond{$i$ \KwTo\Range{$n$}}
%	\AlgoDontDisplayBlockMarkers\SetAlgoNoEnd\SetAlgoNoLine%
%	
%	\caption{Extends haplotypes across a tree sequence $TS$.
%    \comment{I think we can remove this now?}}
%	\label{alg:hap}
%	
%	\SetKwFunction{ex}{Extend Paths}
%	\SetKwFunction{fp}{Find Paths}
%	\DontPrintSemicolon
%	\LinesNotNumbered
%	%\SetAlgoNoEnd
%	\input{A tree sequence $\T$}
%	\output{New tree sequence,$\T'$}
%	\BlankLine
%	\Fn{\fp (tree sequence $\T$, forwards = \tn{True})}{
%	{
%		\eIf{forwards=\tn{True}}{$\T = \left(T_1,...,T_{|\T|}\right)$\BlankLine}
%		{\BlankLine
%			$\T = \left(T_{|\T|},..., T_1\right)$\;
%		}
%	}
%		\For{pairs $(T_k, T_{k+1})\in \T\times\T$}{
%		Compute subforests $F_O\subseteq T_k$ and $F_I\subseteq\in T_{k+1}$.\;
%		\For{edges $e$ in $F_O$}{
%			Let $c$ be child node.\;
%			$p_c^{F_O} = [c]$\;
%			$p_c^{F_I} = [c]$\;
%			$\bar{p}_c = []$ Path to be inserted\;
%			\While{$\exists f\in F_O$ such that $\tn{child}(f)=c$ and $\tn{deg}(\tn{parent}(f))=0$}{
%				$p = \tn{parent}(f)$\;
%				Append $p$ to $p_c^{F_O}$\;
%				$c = p$\;
%			}
%			\While{$\exists f\in F_I$ such that $\tn{child}(f)=c$ and $\tn{deg}(\tn{parent}(f))<3$}{
%				$p =\tn{parent}(f)$\;
%				Append $p$ to $p_c^{F_I}$\;
%				$c = p$\;
%			}
%			\If{($p_c^{F_O}\cap p_c^{F_I})\backslash\{c\}\neq\emptyset$}{
%				Merge paths up to intersection point\;
%				$\bar{p}_c = \hat{p}_c^{F_I} \cup \hat{p}^{F_I}_c$\;
%				and sort by node time.\;
%			}
%			Insert $\bar{p}_c$ into $T_{k+1}$\;		
%		}
%	}\;
%	Update $\T$.\;
%	\KwRet{$\T$}\;
%}
%\BlankLine						
%\Fn{\ex ($\T$)}{
%	$\T' \gets $ \fp($\T$, forwards =\tn{True})\;
%	$\T' \gets $ \fp($\T$, forwards = \tn{False})\;
%	\While{Number of edges in $\T$ $\neq$ Number of edges in $\T'$}{
%		$\T' \gets $ \fp($\T$, fowards=\tn{True})\;
%		$\T' \gets $ \fp($\T$, fowards=\tn{False})\;
%		
%	}
%	\KwRet{$\T'$}\;
%}
%\end{algorithm2e}
%
%% Can most likely delete the extend-edges algorithm %%
%\begin{algorithm2e}[!ht] 
%	
%\SetStartEndCondition{ }{}{}%
%\SetKwProg{Fn}{def}{\string:}{}
%\SetKwFunction{Range}{range}%%
%\SetKw{KwTo}{in}
%\SetKwFor{For}{for}{\string:}{}%
%\SetKwIF{If}{ElseIf}{Else}{if}{:}{elif}{else:}{}%
%\SetKwFor{While}{while}{:}{fintq}%
%\SetKw{Break}{break}
%\newcommand\forcond{$i$ \KwTo\Range{$n$}}
%\AlgoDontDisplayBlockMarkers\SetAlgoNoEnd\SetAlgoNoLine%
%
%\caption{Extends edges across a tree sequence $TS$. 
%\comment{Can be removed, probably -- unless this seems a lot simpler?}}
%\label{alg:edge}
%
%\SetKwFunction{ex}{Extend Edges}
%\SetKwFunction{fwd}{Extend}
%\DontPrintSemicolon
%\LinesNotNumbered
%%\SetAlgoNoEnd
%\input{A tree sequence $\T$}
%\output{New tree sequence,$\T'$}
%
%\BlankLine 
%
%\Fn{\fwd (tree sequence $\T$, forwards = \tn{True})}{
%{	
%\eIf{forwards=\tn{True}}{$\T = \left(T_1,...,T_{|\T|}\right)$\BlankLine}
%{\BlankLine
%	$\T = \left(T_{|\T|},..., T_1\right)$\;}
%}
%	\For{$T_k\in \T$}{
%	Find all edge pairs $(e_1,e_2)$ such that $e_1 = a\to b$ and $e_2 = b\to c$ for some nodes $a,b,c$.\;
%	\For{edges $f$ in $T_{k+1}$}{
%		\If{$f = a \to c$ and $b$ is not in $T_{k+1}$}{
%		Remove $f$ from $T_{k+1}$.\;
%		Add $e_1$ and $e_2$ to $T_{k+1}$.\;
%		Update $\T$.\;
%	}
%	}
%}\;						
%\KwRet{$\T$}\;
%}
%\BlankLine						
%\Fn{\ex ($\T$, iter=100)}{
%	\For{$*$ \KwTo \Range(iter)}{
%		$\T' \gets \T$.\fwd(fowards=\tn{True})\;
%		$\T' \gets \T$.\fwd(fowards=\tn{False})\;
%		\If{Number of edges in $\T$ = Number of edges in $\T'$}{
%			\Break\BlankLine}
%		}
%}
%\KwRet{$\T'$}\;
%\end{algorithm2e}

\begin{figure}
	\includegraphics[width=0.9\linewidth]{newplots_wo_ee/better_unary_spans_ep_notlog.pdf}
	\caption{\comment{DELETE}}
%	\caption{Correct Unary Span for Extend Haplotypes}
	\label{fig:correct-unary-span}
\end{figure}


\end{document}
